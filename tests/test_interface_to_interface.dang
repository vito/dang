# Test interface-to-interface assignment and subtyping

# Define a hierarchy of interfaces
interface Named {
  pub name: String!
}

interface Identifiable {
  pub id: String!
}

# An interface that extends both (structural subtyping)
interface Entity {
  pub id: String!
  pub name: String!
}

# A concrete type implementing Entity (which structurally implements both Named and Identifiable)
type Person implements Entity {
  pub id: String! = "person-123"
  pub name: String! = "Alice"
  pub email: String! = "alice@example.com"
}

# Test: Person implements Entity
let person = Person
assert { person.id == "person-123" }
assert { person.name == "Alice" }
assert { person.email == "alice@example.com" }

# Test: Entity should structurally implement Named (has all required fields)
# Since Entity has 'name: String!', it should be assignable to Named
type EntityHolder {
  pub entity: Entity! = Person
}

let holder = EntityHolder
let entity: Entity! = holder.entity
assert { entity.id == "person-123" }
assert { entity.name == "Alice" }

# Test: Entity should structurally implement Identifiable (has all required fields)
# Since Entity has 'id: ID!', it should be assignable to Identifiable
let entityAsId: Entity! = holder.entity
assert { entityAsId.id == "person-123" }
