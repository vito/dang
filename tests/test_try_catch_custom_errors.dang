# Test custom error types implementing the Error interface

type NotFoundError implements Error {
  pub message: String!
  pub resource: String!
}

type ValidationError implements Error {
  pub message: String!
  pub field: String!
}

# raise a custom error type, catch-all
pub result = try {
  raise NotFoundError(message: "user not found", resource: "User")
} catch {
  err => err.message
}

assert { result == "user not found" }

# catch with type patterns â€” like case but directly in catch
pub matched = try {
  raise ValidationError(message: "too short", field: "name")
} catch {
  v: ValidationError => "invalid " + v.field + ": " + v.message
  n: NotFoundError => "missing " + n.resource
}

assert { matched == "invalid name: too short" }

# match the other branch
pub matched2 = try {
  raise NotFoundError(message: "gone", resource: "Post")
} catch {
  v: ValidationError => "invalid " + v.field
  n: NotFoundError => "missing " + n.resource
}

assert { matched2 == "missing Post" }

# type patterns with a catch-all fallback
pub withFallback = try {
  raise "plain error"
} catch {
  v: ValidationError => "validation"
  err => "other: " + err.message
}

assert { withFallback == "other: plain error" }

# custom errors propagate through function calls
pub validate(name: String!): String! {
  if (name == "") {
    raise ValidationError(message: "must not be empty", field: "name")
  } else {
    name
  }
}

pub validated = try {
  validate("")
} catch {
  v: ValidationError => v.field + " " + v.message
}

assert { validated == "name must not be empty" }

# non-error path works normally
pub ok = try {
  validate("Alice")
} catch {
  err => "unreachable"
}

assert { ok == "Alice" }

print("Custom error type tests passed!")
