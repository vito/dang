# Test that private required fields must be included in constructor

# Type with both public and private required fields (no defaults)
type Foo {
  pub required: String!
  let requiredButPrivate: String!

  pub getPrivate: String! {
    self.requiredButPrivate
  }
}

# This should require both arguments to construct
# The constructor should be: Foo(required: String!, requiredButPrivate: String!)
let instance = Foo("public_value", "private_value")

assert { instance.required == "public_value" }
assert { instance.getPrivate == "private_value" }

# Type with private required field and public with default
type Mixed {
  pub publicWithDefault: String! = "default"
  let privateRequired: Int!

  pub getPrivateInt: Int! {
    self.privateRequired
  }
}

# Constructor should require the private field since it has no default
# Parameters are in declaration order: publicWithDefault, privateRequired
let mixed1 = Mixed("default", 42)
assert { mixed1.publicWithDefault == "default" }
assert { mixed1.getPrivateInt == 42 }

let mixed2 = Mixed("custom", 99)
assert { mixed2.publicWithDefault == "custom" }
assert { mixed2.getPrivateInt == 99 }

# Type with private field that HAS a default - should NOT be in constructor
type WithPrivateDefault {
  pub publicRequired: String!
  let privateWithDefault: Int! = 100

  pub getPrivateDefault: Int! {
    self.privateWithDefault
  }
}

# Constructor should only require publicRequired, not privateWithDefault
let withDefault = WithPrivateDefault("test")
assert { withDefault.publicRequired == "test" }
assert { withDefault.getPrivateDefault == 100 }

print("Private required field tests passed!")
