# Test scope reopening functionality

# Create a base object to reopen
pub base = {{ a: 1, b: "hello", c: "wtf" }}
pub copy = base

# Test basic reopening - should override a field
base << { a = 42 }
assert { base.a == 42 }
assert { base.b == "hello" }

# Test that original is unchanged
assert { copy.a == 1 }
assert { copy.b == "hello" }

# Test multiple field updates
base << {
  a = 100
  b = "world"
}
assert { base.a == 100 }
assert { base.b == "world" }

# Test with variables
base << {
  a = (a + 10)
}
assert { base.a == 110 }
assert { base.b == "world" }

# Test nested updates
pub config = {{
  contents: {{
    packages: []
    repositories: []
    keyring: []
  }}
  cmd: "original"
  environment: {{
    PATH: "/usr/local/bin:/usr/bin:/bin"
  }}
  archs: []
}}
pub configCopy = config
config << {
  contents << {
    packages += ["foo"]
  }
  cmd = "some command"
}
assert { config.cmd == "some command" }
assert { config.contents.packages == ["foo"] }
assert { configCopy.cmd == "original" }
assert { configCopy.contents.packages == [] }

# Test nested updates within a class
cls MyClass {
  pub config = {{
    contents: {{
      packages: []
      repositories: []
      keyring: []
    }}
    cmd: "original"
    environment: {{
      PATH: "/usr/local/bin:/usr/bin:/bin"
    }}
    archs: []
  }}

  pub new: MyClass! {
    self
  }

  pub withPackages(packages: [String!]!): MyClass! {
    pvt outer = packages
    self << {
      config << {
        contents << {
          packages += args.packages
        }
        cmd = "some command"
      }
    }
  }
}
assert { MyClass.new.withPackages(["foo"]).config.cmd == "some command" }
assert { MyClass.new.withPackages(["foo"]).config.contents.packages == ["foo"] }
assert { MyClass.new.config.cmd == "original" }
assert { MyClass.new.config.contents.packages == [] }

print("Reopening tests passed!")
