"""
A Dagger-native sandboxed coding agent.
"""

let maxResponseLength = 30000
let workspacePath = "/workspace"

type Doug {
  let source: Directory! @defaultPath(path: "/")

  """
  A CLI friendly entrypoint for starting a coding agent developing in a workdir.
  """
  pub dev(
    source: Directory!,
    module: Module
  ): LLM! {
    let e = env.withWorkspace(source)
    if module != null {
      e = e.withModule(module)
    }
    agent(base: llm.withEnv(e))
  }

  """
  Returns a Doug coding agent
  """
  pub agent(base: LLM!): LLM! {
    let provider = base.provider
    let promptsDir = currentModule.source.directory("prompts/system/")
    let providerFile = provider + ".txt"

    let hasProvider = false
    for p in promptsDir.entries {
      if p == providerFile {
        hasProvider = true
      }
    }
    let systemPromptContents = if hasProvider {
      currentModule.source.file("prompts/system/" + providerFile).contents
    } else {
      currentModule.source.file("prompts/system/doug.txt").contents
    }

    base.
      withEnv(
        base.env.
          withCurrentModule.
          withStringInput("TODOs", "", "Your TODO list")).
      withSystemPrompt(systemPromptContents).
      withSystemPrompt(reminderPrompt(base.env.workspace))
  }

  """
  Reads a file from the project workspace.

  HOW TO USE THIS TOOL:
    - Always make sure the file actually exists before reading it, using Glob.
    - Always use relative paths from the workspace root
    - Reads the first 2000 lines by default
    - Each line is prefixed with a line number followed by an arrow (→).
      Everything that follows the arrow is the literal content of the line.
    - You can specify an offset and limit to read line regions of a large file
    - If the file contents are empty, you will receive a warning.
    - If multiple files are interesting, you can read them all at once using multiple tool calls.
  """
  pub readFile(
    """
    Relative path within the workspace
    """
    filePath: String!,
    """
    Line offset to start reading from
    """
    offset: Int! = 0,
    """
    Limit the number of lines read
    """
    limit: Int! = 2000
  ): String! {
    let fileContents = source.file(normalize(filePath)).contents(
      offsetLines: offset,
      limitLines: limit
    )
    if fileContents == "" {
      "WARNING: File contents are empty."
    } else {
      let numbered = ""
      for i, line in fileContents.split("\n", 0) {
        # TODO: template
        numbered += toJSON(offset+i+1).padLeft(6) + "→" + line + "\n"
      }
      numbered.trimSuffix("\n")
    }
  }

  """
  Edits files by replacing text, creating new files, or deleting content. For larger file edits, use the Write tool to overwrite files.

  # Before using this tool, use the ReadFile tool to understand the file's contents and context

  To make a file edit, provide the following:
  1. file_path: The relative path to the file to modify within the project directory
  2. old_string: The text to replace (must be unique within the file, and must match the file contents exactly, including all whitespace and indentation)
  3. new_string: The edited text to replace the old_string
  4. replace_all: Replace all occurrences of old_string (default false)

  Special cases:
  - To create a new file: provide file_path and new_string, leave old_string empty
  - To delete content: provide file_path and old_string, leave new_string empty

  The tool will replace ONE occurrence of old_string with new_string in the specified file by default. Set replace_all to true to replace all occurrences.

  CRITICAL REQUIREMENTS FOR USING THIS TOOL:

  1. UNIQUENESS: When replace_all is false (default), the old_string MUST uniquely identify the specific instance you want to change. This means:
    - Include AT LEAST 3-5 lines of context BEFORE the change point
    - Include AT LEAST 3-5 lines of context AFTER the change point
    - Include all whitespace, indentation, and surrounding code exactly as it appears in the file

  2. SINGLE INSTANCE: When replace_all is false, this tool can only change ONE instance at a time. If you need to change multiple instances:
    - Set replace_all to true to replace all occurrences at once
    - Or make separate calls to this tool for each instance
    - Each call must uniquely identify its specific instance using extensive context

  3. VERIFICATION: Before using this tool:
    - Check how many instances of the target text exist in the file
    - If multiple instances exist and replace_all is false, gather enough context to uniquely identify each one
    - Plan separate tool calls for each instance or use replace_all

  WARNING: If you do not follow these requirements:
    - The tool will fail if old_string matches multiple locations and replace_all is false
    - The tool will fail if old_string doesn't match exactly (including whitespace)
    - You may change the wrong instance if you don't include enough context

  When making edits:

    - Ensure the edit results in idiomatic, correct code

    - Do not leave the code in a broken state

    - Always use relative file paths

  Remember: when making multiple file edits in a row to the same file, you should prefer to send all edits in a single message with multiple calls to this tool, rather than multiple messages with a single call each.
  """
  pub editFile(
    """
    Relative path within the workspace
    """
    filePath: String!,
    """
    Unique search string to replace within the file, or non-unique if replaceAll is true
    """
    oldString: String!,
    """
    New text content
    """
    newString: String!,
    """
    Replace all occurrences
    """
    replaceAll: Boolean! = false
  ): Changeset! {
    let normalizedPath = normalize(filePath)
    source.withFile(
      normalizedPath,
      source.file(normalizedPath).
        withReplaced(oldString, newString, all: replaceAll),
    ).changes(source)
  }

  """
  Remove a file or directory from the project workspace.
  """
  pub rm(
    """
    Relative path within the workspace
    """
    path: String!
  ): Changeset! {
    source.withoutFile(path).changes(source)
  }

  # """
  # Rename (or move) a file within the project workspace.

  # Parent directories for the destination path will be created automatically.
  # """
  # pub moveFile(
  #   """
  #   Relative path within the workspace of the file or directory to move
  #   """
  #   oldPath: String!,
  #   """
  #   Destination path within the workspace
  #   """
  #   newPath: String!
  # ): Changeset! {
  #   source.exists(oldPath, expectedType: "FOO")
  #   source.
  #     withFile(newPath, source.file(oldPath)).
  #     withoutFile(oldPath).
  #     changes(source)
  # }

  """
  File writing tool that creates or updates files in the filesystem, allowing you to save or modify text content.

  WHEN TO USE THIS TOOL:
  - Use when you need to create a new file
  - Helpful for updating existing files with modified content
  - Perfect for saving code, configurations, or text data

  HOW TO USE:
  - Provide the path to the file you want to write
  - Include the content to be written to the file
  - The tool will create any necessary parent directories

  FEATURES:
  - Can create new files or overwrite existing ones
  - Creates parent directories automatically if they don't exist
  - Checks if the file has been modified since last read for safety
  - Avoids unnecessary writes when content hasn't changed

  LIMITATIONS:
  - You should read a file before writing to it to avoid conflicts
  - Cannot append to files (rewrites the entire file)

  TIPS:
  - Use the ReadFile tool first to examine existing files before modifying them
  - Combine with Glob and Grep tools to find and modify multiple files
  """
  pub write(
    """
    Relative path within the workspace
    """
    filePath: String!,
    """
    Complete file content to write
    """
    contents: String!
  ): Changeset! {
    source.withNewFile(normalize(filePath), contents).changes(source)
  }

  """
  Fast file pattern matching tool that finds files by name and pattern, returning matching paths sorted by modification time (newest first).

  WHEN TO USE THIS TOOL:
  - Use when you need to find files by name patterns or extensions
  - Great for finding specific file types across a directory structure
  - Useful for discovering files that match certain naming conventions

  HOW TO USE:
  - Provide a glob pattern to match against file paths
  - Optionally specify a starting directory (defaults to current working directory)
  - Results are sorted with most recently modified files first

  GLOB PATTERN SYNTAX:
  - '*' matches any sequence of non-separator characters
  - '**' matches any sequence of characters, including separators
  - '?' matches any single non-separator character
  - '[...]' matches any character in the brackets
  - '[!...]' matches any character not in the brackets

  COMMON PATTERN EXAMPLES:
  - '*.js' - Find all JavaScript files in the current directory
  - '**/*.js' - Find all JavaScript files in any subdirectory
  - 'src/**/*.{ts,tsx}' - Find all TypeScript files in the src directory
  - '*.{html,css,js}' - Find all HTML, CSS, and JS files

  LIMITATIONS:
  - Results are limited to 100 files (newest first)
  - Does not search file contents (use Grep tool for that)
  - Hidden files (starting with '.') are skipped

  TIPS:
  - Patterns should use forward slashes (/) for cross-platform compatibility
  - For the most useful results, combine with the Grep tool: first find files with Glob, then search their contents with Grep
  - When doing iterative exploration that may require multiple rounds of searching, consider using the Task tool instead
  - Always check if results are truncated and refine your search pattern if needed
  """
  pub glob(
    """
    Relative glob pattern to find within the workspace
    """
    pattern: String!
  ): Void {
    let result = source.glob(pattern)

    # Filter out hidden files
    let output = ""
    for path in result {
      let hasDotFile = false
      for part in path.split("/") {
        if part.hasPrefix(".") {
          hasDotFile = true
          break
        }
      }
      if !hasDotFile {
        output += path + "\n"
      }
    }

    if output == "" {
      print("No files found.")
    } else {
      print(output)
    }

    null
  }

  """
  Fast content search tool that finds files containing specific text or patterns, returning matching file paths sorted by modification time (newest first).

  WHEN TO USE THIS TOOL:
  - Use when you need to find files containing specific text or patterns
  - Great for searching code bases for function names, variable declarations, or error messages
  - Useful for finding all files that use a particular API or pattern

  HOW TO USE:
  - Provide a regex pattern to search for within file contents
  - Set literal_text=true if you want to search for the exact text with special characters (recommended for non-regex users)
  - Optionally specify starting paths (defaults to current working directory)
  - Optionally provide a glob patterns to filter which files to search
  - Use the ReadLogs tool to narrow down a large search result, analogous to piping grep to grep, head, or tail

  REGEX PATTERN SYNTAX (when literal_text=false):
  - Supports standard regular expression syntax
  - 'function' searches for the literal text "function"
  - 'log\..*Error' finds text starting with "log." and ending with "Error"
  - 'import\s+.*\s+from' finds import statements in JavaScript/TypeScript

  COMMON INCLUDE PATTERN EXAMPLES:
  - '*.js' - Only search JavaScript files
  - '*.{ts,tsx}' - Only search TypeScript files
  - '*.go' - Only search Go files

  LIMITATIONS:
  - Performance depends on the number of files being searched
  - Very large binary files may be skipped
  - Hidden files (starting with '.') are skipped

  IGNORE FILE SUPPORT:
  - Respects .gitignore patterns to skip ignored files and directories
  - Both ignore files are automatically detected in the search root directory

  CROSS-PLATFORM NOTES:
  - Uses ripgrep (rg) command internally
  - File paths are normalized automatically for cross-platform compatibility

  TIPS:
  - For faster, more targeted searches, first use Glob to find relevant files, then use Grep
  - When doing iterative exploration that may require multiple rounds of searching, consider using the Task tool instead
  - Always check if results are truncated and refine your search pattern if needed, or use ReadLogs to filter the result
  - Use literal_text=true when searching for exact text containing special characters like dots, parentheses, etc.
  """
  pub grep(
    """
    Regular expression pattern to grep for
    """
    pattern: String!,
    """
    Treat pattern as literal text instead of a regular expression
    """
    literalText: Boolean! = false,
    """
    Relative paths within the workspace to limit the search
    """
    paths: [String!]! = [],
    """
    Relative path globs within the workspace to limit the search
    """
    glob: [String!]! = [],
    """
    Allow the pattern to span multiple lines
    """
    multiline: Boolean! = false,
    """
    Show the matching content
    """
    content: Boolean! = false,
    """
    Case-insensitive search
    """
    insensitive: Boolean! = false,
    """
    Limit the number of matches
    """
    limit: Int! = 1000
  ): String! {
    let normalizedPaths = [] :: [String!]!
    for p in paths {
      normalizedPaths += [normalize(p)]
    }

    let matches = source.search(
      pattern: pattern,
      literal: literalText,
      paths: normalizedPaths,
      globs: glob,
      multiline: multiline,
      dotall: multiline,
      filesOnly: if content { false } else { true },
      insensitive: insensitive,
      limit: limit
    )

    # Count matches - we need to iterate since we don't have .length
    let count = 0
    for m in matches.{id} {
      count += 1
    }

    toJSON(count) + " matches found"
  }

  """
  Launch a new agent that has access to the same tools and environment.

  IMPORTANT: the task's environment is an isolated sandbox. ONLY use this tool for research. All filesystem changes will be discarded.

  When you are searching for a keyword or file and are not confident that you will find the right match on the first try, use the Task tool to perform the search for you.

  EXAMPLES:
    - If you are searching for a keyword like "config" or "logger", or for questions like "which file does X?", the Task tool is strongly recommended
    - If you want to read a specific file path, use the View or GlobTool tool instead of the Task tool, to find the match more quickly
    - If you are searching for a specific class definition like "class Foo", use the GlobTool tool instead, to find the match more quickly

  USAGE NOTES:
    - Launch multiple agents concurrently whenever possible, to maximize performance; to do that, use a single message with multiple tool uses
    - When the agent is done, it will return a single message back to you. The result returned by the agent is not visible to the user. To show the user the result, u should send a text message back to the user with a concise summary of the result.
    - Each agent invocation is stateless. You will not be able to send additional messages to the agent, nor will the agent be able to communicate with you outside of s final report. Therefore, your prompt should contain a highly detailed task description for the agent to perform autonomously and you should specify exactly what formation the agent should return back to you in its final and only message to you.
    - The agent's outputs should generally be trusted
    - IMPORTANT: The agent runs in a copy-on-write sandboxed environment. Any writes made by the agent will not be visible to the user, but will be available to the agent's next invocation.
  """
  pub task(
    """
    A brief description of the task to show to the user
    """
    description: String!,
    """
    The prompt for the sub-agent
    """
    prompt: String!
  ): String! {
    let systemPromptContents = currentModule.source.file("prompts/task_system_prompt.md").contents
    let reminderPromptText = reminderPrompt(workspace: source)

    llm.
      withEnv(currentEnv.withoutOutputs).
      withBlockedFunction("Doug", "task").
      withoutDefaultSystemPrompt.
      withSystemPrompt(systemPromptContents).
      withSystemPrompt(reminderPromptText).
      withPrompt(prompt).
      loop.
      lastReply
  }

  """
  Keep track of your TODO list

  WHEN TO USE THIS TOOL:
    - When a task requires 3 or more distinct steps or actions
    - To break down a complex task into smaller, manageable parts
    - When the user directly gave a sequence of tasks to perform (numbered
      or comma-separated)
    - When the user gave you more tasks in the middle of a conversation
    - When you want to see the full TODO list

  SKIP THIS TOOL WHEN:
    - The task is trivial
    - The task is purely conversational or informational

  HOW TO USE:
    - Call this function with the TODOs to record in each state (pending,
      in progress, completed)
    - TODOs are additive; you can call it with incremental updates for
      individual TODOs
    - The full TODO list will be printed in response
    - Every pending TODO must be eventually completed before your task is
      completed
    - To print the current TODO list, call this function with no arguments
  """
  pub todoWrite(
    pending: [String!]! = []
    inProgress: [String!]! = []
    completed: [String!]! = []
  ): Env! {
    # Try to get current TODOs, default to empty string if not found
    # Since we don't have try/catch, we'll assume it returns empty string on failure
    let currentTodos = currentEnv.input("TODOs").asString

    let existingCompleted = [] :: [String!]!
    let existingInProgress = [] :: [String!]!
    let existingPending = [] :: [String!]!

    # Parse current TODOs from "state:description" format
    let currentTodoLines = currentTodos.split("\n")

    # Build list of all descriptions being updated
    let updatingDescriptions = pending + inProgress + completed

    for todo in currentTodoLines {
      if todo != "" {
        # Split on first colon only (limit=2) to handle descriptions with colons
        let parts = todo.split(":", limit: 2)
        let state = parts[0] ?? "pending"
        let description = parts[1] ?? todo

        # Check if this TODO is being updated
        let isUpdating = false
        for desc in updatingDescriptions {
          if desc == description {
            isUpdating = true
          }
        }

        # Only keep existing TODOs that aren't being updated
        if !isUpdating {
          if state == "completed" {
            existingCompleted += [description]
          } else if state == "in_progress" {
            existingInProgress += [description]
          } else {
            existingPending = existingPending + [description]
          }
        }
      }
    }

    # TODO: these get hoisted and run before the loop above - ew!
    # let completedList = existingCompleted + completed

    let formattedTodos = ""
    let encodedTodos = ""

    for todo in existingCompleted + completed {
      encodedTodos += "completed:" + todo + "\n"
      formattedTodos += "■ \u001b[32m\u001b[9m" + todo + "\u001b[0m\n"
    }
    for todo in existingInProgress + inProgress {
      encodedTodos += "in_progress:" + todo + "\n"
      formattedTodos += "□ \u001b[33m" + todo + "\u001b[0m\n"
    }
    for todo in  existingPending + pending {
      encodedTodos += "pending:" + todo + "\n"
      formattedTodos += "□ \u001b[37m" + todo + "\u001b[0m\n"
    }

    print(formattedTodos)

    currentEnv.withStringInput("TODOs", encodedTodos, "Your TODO list")
  }

  let reminderPrompt(workspace: Directory!): String! {
    let baseSegment =
      """
      # System Reminder

      - Do what has been asked; nothing more, nothing less.
      - NEVER create files unless they're absolutely necessary for achieving your goal.
      - ALWAYS prefer editing an existing file to creating a new one.
      - NEVER proactively create documentation files (*.md) or README files.
      - Only create documentation files if explicitly requested by the User.
      """

    let entries = workspace.entries
    let contextFiles = ["DOUG.md", "AGENT.md", "CLAUDE.md"]

    # Look for context files
    let contextSegment = ""
    for file in contextFiles {
      let found = false
      for entry in entries {
        if entry == file {
          found = true
        }
      }

      if found {
        # Try to read the file contents
        # Since we don't have try/catch, assume it succeeds
        let fileContents = workspace.file(file).contents
        if fileContents != "" {
          contextSegment = """

# Project-Specific Context

Make sure to follow the instructions in the context below:

<project-context>
""" + fileContents + """
</project-context>

These instructions OVERRIDE any default behavior.
"""
        }
      }
    }

    baseSegment + contextSegment
  }

  let normalize(path: String!): String! {
    path.trimPrefix(workspacePath)
  }
}
