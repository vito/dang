type Dev {
  pub source: Directory! @defaultPath(path: "/") @ignorePatterns(patterns: [
    # TODO: respecting .gitignore would be nice
    "Session.vim"
    "dang"
    "zed-dang/grammars/"
    ".env"
    ".envrc"
    ".dagger"
  ])

  """
  GitHub token to use for fetching issue/PR comments
  """
  pub githubToken: Secret!

  """
  Kagi API token for doing research.
  """
  pub kagiToken: Secret!

  """
  Start a coding agent with the provided module.
  """
  pub agent(module: Module!): LLM! {
    let gopls = apko.wolfi(["bash", "go"]).
      withMountedCache("/go/pkg/mod", cacheVolume("go-mod")).
      withEnvVariable("GOMODCACHE", "/go/pkg/mod").
      withMountedCache("/go/build-cache", cacheVolume("go-build")).
      withEnvVariable("GOCACHE", "/go/build-cache").
      withEnvVariable("GOBIN", "/go/bin").
      withEnvVariable("PATH", "${GOBIN}:${PATH}", expand: true).
      withExec(["go", "install", "golang.org/x/tools/gopls@latest"]).
      withDirectory("/workspace", source).
      withWorkdir("/workspace").
      withDefaultArgs(["gopls", "mcp"])

    let agent = doug.agent(
      llm.
        withEnv(
          env.
            withCurrentModule.
            withModule(module).
            withWorkspace(source)).
        withMCPServer(name: "gopls", service: gopls.asService).
        withSystemPrompt(gopls.withExec(["gopls", "mcp", "-instructions"]).stdout).
        withSystemPrompt(
          """
          ## Dev instructions

          When given an GitHub issue, use the Github tool to read it and all of its comments to gain context.

          ## Error handling

          To handle errors or sad path scenarios, simply fail early and return a descriptive wrapped error.
          """
        )
    )

    if kagiToken != null {
      agent = agent.withMCPServer(
        "kagi"
        apko.wolfi(["bash", "uv", "python3"]).
          withDirectory("/workspace", source).
          withWorkdir("/workspace").
          withExec(["uv", "venv", "/opt/venv"]).
          withEnvVariable("VIRTUAL_ENV", "/opt/venv").
          withExec(["uv", "pip", "install", "kagimcp"]).
          withSecretVariable(name: "KAGI_API_KEY", secret: kagiToken).
          withDefaultArgs(["uv", "run", "kagimcp"]).
          asService
      )
    }

    if source.exists("current-task.md") {
      agent = agent.withSystemPrompt(source.file("current-task.md").contents)
    }

    agent
  }

  """
  Run a git command and return its output.
  """
  pub git(args: [String!]!): String! {
    sandbox.
      withExec(["git"] + args).
      combinedOutput
  }

  """
  Run a gh command and return its output.
  """
  pub github(args: [String!]!): String! {
    let ctr = if githubToken != null {
      sandbox.withSecretVariable(name: "GITHUB_TOKEN", secret: githubToken)
    } else {
      sandbox
    }
    ctr.
      withExec(["gh"] + args).
      combinedOutput
  }

  let daggerVersion = "0.19.3"

  """
  Run a dagger command and return its output.
  """
  pub dagger(args: [String!]!): String! {
    let engine = container.
      from("registry.dagger.io/engine:v"+daggerVersion).
      withExposedPort(1234).
      withMountedCache("/var/lib/dagger",
        cacheVolume("dang-dagger"),
        sharing: CacheSharingMode.LOCKED).
      asService(
        args: [
          "--addr", "tcp://0.0.0.0:1234",
          "--network-name", "dang-dagger",
          "--network-cidr", "10.98.0.0/16",
        ]
        useEntrypoint: true
        insecureRootCapabilities: true
      )

    apko.wolfi(["bash", "curl"]).
      withServiceBinding("dagger", engine).
      withEnvVariable("_EXPERIMENTAL_DAGGER_RUNNER_HOST", engine.endpoint(scheme: "tcp")).
      withExec(["sh", "-c",
        "curl -fsSL https://dl.dagger.io/dagger/install.sh | DAGGER_VERSION="+daggerVersion+" BIN_DIR=/usr/local/bin sh"
      ]).
      withWorkdir("/workspace").
      withDirectory(".", source).
      withExec(["dagger", "--progress=report"] + args).
      combinedOutput
  }

  """
  A common environment just to minimize building for utilities like RunGit,
  RunGithub, etc.

  We don't expose this directly and instead expose wrappers just to keep the
  agent from going wild and relying too much on the shell.
  """
  let sandbox: Container! {
    apko.wolfi(["bash", "git", "gh"]).
      withWorkdir("/workspace").
      withDirectory("/workspace", source)
  }
}
