{
  package dang

  import (
    "fmt"
    "strconv"
    "bytes"
    "strings"
  )
}

Dang <- _ eles:(e:Expr Sep { return e, nil })* last:Expr? _ !. {
  return &ModuleBlock{
    Forms: sliceOfAppend[Node](eles, last),
    Loc: c.Loc(),
  }, nil
}

_ "whitespace" <- ([ \t\r\n] / CommentToken)*
_lineSpace <- [ \t]* CommentToken?

Sep <- (_ CommaToken / _lineSpace '\n') _
CommaToken <- ','

Expr <- Import / AnnotatedDecl / Interface / Enum / Scalar / Class / Slot / DirectiveDecl / Reassignment / Form

AnnotatedDecl <- docstring:DocString _ decl:(Interface / Enum / Scalar / Class / Slot / DirectiveDecl) {
  switch node := decl.(type) {
  case *InterfaceDecl:
    node.DocString = docstring.(string)
    return node, nil
  case *EnumDecl:
    node.DocString = docstring.(string)
    return node, nil
  case *ScalarDecl:
    node.DocString = docstring.(string)
    return node, nil
  case *ClassDecl:
    node.DocString = docstring.(string)
    return node, nil
  case *SlotDecl:
    node.DocString = docstring.(string)
    return node, nil
  case *DirectiveDecl:
    node.DocString = docstring.(string)
    return node, nil
  default:
    return decl, nil
  }
}

Form <- Conditional / ForLoop / Lambda / Match / Assert / Break / Continue / DefaultExpr / TypeHint / Term

Term <- UnaryExpr / IndexOrCall / SelectOrCall / Literal / List / Object / Block / ParenForm / SymbolOrCall

UnaryExpr <- '!' _ expr:Term {
  return &UnaryNegation{
    Expr: expr.(Node),
    Loc: c.Loc(),
  }, nil
}

ParenForm <- '(' _ expr:Form _ ')' {
  return expr.(Node), nil
}

// Handle Symbol followed by optional ()
SymbolOrCall <- Call / Symbol
Call <- name:Id args:ArgValues {
  // Symbol followed by () - create FunCall
  argRecord := Record(args.([]Keyed[Node]))
  return &FunCall{
    Fun: &Symbol{
      Name: name.(string),
      Loc: c.Loc(),
    },
    Args: argRecord,
    Loc: c.Loc(),
  }, nil
}
Symbol <- name:Id {
  // Just a Symbol
  return &Symbol{
    Name: name.(string),
    AutoCall: true,
    Loc: c.Loc(),
  }, nil
}

// Handle Select followed by optional (), or ObjectSelection
SelectOrCall <- left:Term _ DotToken _ selection:(ObjectSelection / name:Id args:ArgValues?) {
  switch sel := selection.(type) {
  case *ObjectSelection:
    // Object selection: obj.{field1, field2}
    sel.Receiver = left.(Node)
    return sel, nil
  case []interface{}:
    // Regular field access with optional args
    name := sel[0].(string)
    args := sel[1]
    if args != nil {
      // Select followed by () - create FunCall
      argRecord := Record(args.([]Keyed[Node]))
      return &FunCall{
        Fun: &Select{
          Receiver: left.(Node),
          Field:    name,
          Loc:      c.Loc(),
        },
        Args: argRecord,
        Loc:  c.Loc(),
      }, nil
    } else {
      // Just a Select
      return &Select{
        Receiver: left.(Node),
        Field:    name,
        AutoCall: true,
        Loc:      c.Loc(),
      }, nil
    }
  default:
    return nil, fmt.Errorf("unexpected selection type")
  }
}

// Handle indexing operations like foo[0]
IndexOrCall <- left:Term _ '[' _ index:Form _ ']' args:ArgValues? {
  if args != nil {
    // Index followed by () - create FunCall
    argRecord := Record(args.([]Keyed[Node]))
    return &FunCall{
      Fun: &Index{
        Receiver: left.(Node),
        Index:    index.(Node),
        Loc:      c.Loc(),
      },
      Args: argRecord,
      Loc:  c.Loc(),
    }, nil
  } else {
    // Just an Index
    return &Index{
      Receiver: left.(Node),
      Index:    index.(Node),
      AutoCall: true,
      Loc:      c.Loc(),
    }, nil
  }
}

ObjectSelection <- '{' _ fields:(f:FieldSelection Sep { return f, nil })* last:FieldSelection? _ '}' {
  return &ObjectSelection{
    Receiver: nil, // Will be set by parent SelectOrCall
    Fields: sliceOfAppend[*FieldSelection](fields, last),
    Loc: c.Loc(),
  }, nil
}

FieldSelection <- name:Id args:ArgValues? selection:('.' sel:ObjectSelection)? {
  var argRecord Record
  if args != nil {
    argRecord = Record(args.([]Keyed[Node]))
  }

  if selection != nil {
    return &FieldSelection{
      Name: name.(string),
      Args: argRecord,
      Selection: selection.([]interface{})[1].(*ObjectSelection),
      Loc: c.Loc(),
    }, nil
  } else {
    return &FieldSelection{
      Name: name.(string),
      Args: argRecord,
      Selection: nil,
      Loc: c.Loc(),
    }, nil
  }
}

Interface <- InterfaceToken _ name:IdSymbol _ block:HeadersBlock {
  return &InterfaceDecl{
    Name: name.(*Symbol),
    Value: block.(*Block),
    Visibility: PublicVisibility,
    Loc: c.Loc(),
  }, nil
}
InterfaceToken <- "interface" !WordChar

Class <- TypeToken _ name:IdSymbol implements:(_ Implements)? directives:(_ app:DirectiveApplication { return app, nil })* _ block:Block {
  return &ClassDecl{
    Name: name.(*Symbol),
    Value: block.(*Block),
    Implements: sliceOf[*Symbol](implements),
    Visibility: PublicVisibility, // TODO
    Directives: sliceOf[*DirectiveApplication](directives),
    Loc: c.Loc(),
  }, nil
}
TypeToken <- "type" !WordChar
Implements <-  ImplementsToken _ first:IdSymbol rest:(_ AndToken _ IdSymbol)* {
  return sliceOfAppend[*Symbol](rest, first), nil
}
ImplementsToken <- "implements" !WordChar

AndToken <- '&'

Enum <- EnumToken _ name:IdSymbol _ '{' _ values:(first:CapsSymbol rest:(_ v:CapsSymbol { return v, nil })* { return sliceOfAppend[*Symbol](rest, first), nil }) _ '}' {
  return &EnumDecl{
    Name: name.(*Symbol),
    Values: values.([]*Symbol),
    Visibility: PublicVisibility,
    Loc: c.Loc(),
  }, nil
}
EnumToken <- "enum" !WordChar

Scalar <- ScalarToken _ name:IdSymbol {
  return &ScalarDecl{
    Name: name.(*Symbol),
    Visibility: PublicVisibility,
    Loc: c.Loc(),
  }, nil
}
ScalarToken <- "scalar" !WordChar

Slot <- TypeAndArgsAndBlockSlot  // pub a(foo: Boolean!): Int! { 1 }
      / TypeAndBlockSlot         // pub a: Int! { 1 }  <- becomes a function that takes an empty record of args, can use other fields
      / TypeAndValueSlot         // pub a: Int! = 1    <- no longer required, default pre-initialized (don't need to worry about mutation)
      / ValueOnlySlot            // pub a = 1              <- as above, type inferred as Int!
      / TypeOnlySlot             // pub a: Int              <- as above, type inferred as Int!

TypeAndValueSlot <- vis:Visibility _ name:IdSymbol _ ColonToken _ type_:Type _ EqualToken _ value:Form directives:(_ app:DirectiveApplication { return app, nil })* {
  return &SlotDecl{
    Name: name.(*Symbol),
    Type_: type_.(TypeNode),
    Value: value.(Node),
    Visibility: vis.(Visibility),
    Directives: sliceOf[*DirectiveApplication](directives),
    Loc: c.Loc(),
  }, nil
}

ValueOnlySlot <- vis:Visibility _ name:IdSymbol _ EqualToken _ val:Form directives:(_ app:DirectiveApplication { return app, nil })* {
  return &SlotDecl{
    Name: name.(*Symbol),
    Value: val.(Node),
    Visibility: vis.(Visibility),
    Directives: sliceOf[*DirectiveApplication](directives),
    Loc: c.Loc(),
  }, nil
}

TypeOnlySlot <- vis:Visibility _ name:IdSymbol _ ColonToken _ type_:Type directives:(_ app:DirectiveApplication { return app, nil })* {
  return &SlotDecl{
    Name: name.(*Symbol),
    Type_: type_.(TypeNode),
    Visibility: vis.(Visibility),
    Directives: sliceOf[*DirectiveApplication](directives),
    Loc: c.Loc(),
  }, nil
}

TypeAndBlockSlot <- vis:Visibility _ name:IdSymbol _ ColonToken _ type_:Type _ block:Block directives:(_ app:DirectiveApplication { return app, nil })* {
  return &SlotDecl{
    Name: name.(*Symbol),
    Type_: FunTypeNode{nil, type_.(TypeNode)},
    Value: &FunDecl{
      FunctionBase: FunctionBase{
        Args: nil,
        Body: block.(*Block),
        Loc: c.Loc(),
      },
      Named: name.(*Symbol).Name,
      Ret: type_.(TypeNode),
      Visibility: vis.(Visibility),
    },
    Visibility: vis.(Visibility),
    Directives: sliceOf[*DirectiveApplication](directives),
    Loc: c.Loc(),
  }, nil
}

TypeAndArgsAndBlockSlot <- vis:Visibility _ name:IdSymbol _ args:ArgTypes _ ColonToken _ type_:Type _ block:Block directives:(_ app:DirectiveApplication { return app, nil })* {
  return &SlotDecl{
    Name: name.(*Symbol),
    Type_: FunTypeNode{args.([]*SlotDecl), type_.(TypeNode)},
    Value: &FunDecl{
      FunctionBase: FunctionBase{
        Args: args.([]*SlotDecl),
        Body: block.(*Block),
        Loc: c.Loc(),
      },
      Named: name.(*Symbol).Name,
      Ret: type_.(TypeNode),
      Visibility: vis.(Visibility),
    },
    Visibility: vis.(Visibility),
    Directives: sliceOf[*DirectiveApplication](directives),
    Loc: c.Loc(),
  }, nil
}

HeaderSlot <- AnnotatedHeaderSlot / TypeAndArgsSlot / TypeOnlyFunSlot

AnnotatedHeaderSlot <- docstring:DocString _ decl:HeaderSlot {
  decl.(*SlotDecl).DocString = docstring.(string)
  return decl, nil
}

TypeAndArgsSlot <- vis:Visibility _ name:IdSymbol _ args:ArgTypes _ ColonToken _ type_:Type directives:(_ app:DirectiveApplication { return app, nil })* {
  return &SlotDecl{
    Name: name.(*Symbol),
    Type_: FunTypeNode{args.([]*SlotDecl), type_.(TypeNode)},
    Visibility: vis.(Visibility),
    Directives: sliceOf[*DirectiveApplication](directives),
    Loc: c.Loc(),
  }, nil
}

TypeOnlyFunSlot <- vis:Visibility _ name:IdSymbol _ ColonToken _ type_:Type directives:(_ app:DirectiveApplication { return app, nil })* {
  return &SlotDecl{
    Name: name.(*Symbol),
    Type_: FunTypeNode{nil, type_.(TypeNode)},
    Visibility: vis.(Visibility),
    Directives: sliceOf[*DirectiveApplication](directives),
    Loc: c.Loc(),
  }, nil
}

Visibility <- PubToken { return PublicVisibility, nil }
            / LetToken { return PrivateVisibility, nil }
PubToken <- "pub" !WordChar
LetToken <- "let" !WordChar

Id <- WordToken
IdSymbol <- name:WordToken {
  return &Symbol{
    Name: name.(string),
    Loc: c.Loc(),
  }, nil
}
WordToken <- !NullToken [a-zA-Z_][a-zA-Z0-9_]* {
  return string(c.text), nil
}
WordChar <- [a-zA-Z0-9_]
UpperId <- UpperToken
UpperToken <- [A-Z][a-zA-Z0-9_]* {
  return string(c.text), nil
}
CapsSymbol <- name:CapsToken {
  return &Symbol{
    Name: name.(string),
    Loc: c.Loc(),
  }, nil
}
CapsToken <- [A-Z][A-Z0-9_]* {
  return string(c.text), nil
}

ArgValues <- '(' _ args:(a:Argument Sep { return a, nil })* last:Argument? _ ')' {
  return sliceOfAppend[Keyed[Node]](args, last), nil
}
ArgTypes <- '(' _ args:(a:ArgType Sep { return a, nil })* last:ArgType? _ ')' {
  return sliceOfAppend[*SlotDecl](args, last), nil
}
ArgType <- docstring:DocString _ slot:(ArgWithDefault / ArgWithBlockDefault / ArgWithType) {
  slotDecl := slot.(*SlotDecl)
  return &SlotDecl{
    Name: slotDecl.Name,
    Type_: slotDecl.Type_,
    Value: slotDecl.Value,
    Directives: slotDecl.Directives,
    DocString: docstring.(string),
    Loc: slotDecl.Loc,
  }, nil
} / slot:(ArgWithDefault / ArgWithBlockDefault / ArgWithType) {
  return slot.(*SlotDecl), nil
}
ArgWithDefault <- name:IdSymbol _ ColonToken _ type_:Type _ directives:DirectiveApplication* _ EqualToken _ value:Form {
  return &SlotDecl{
    Name: name.(*Symbol),
    Type_: type_.(TypeNode),
    Directives: sliceOf[*DirectiveApplication](directives),
    Value: value.(Node),
    Loc: c.Loc(),
  }, nil
}
ArgWithBlockDefault <- name:IdSymbol _ ColonToken _ type_:Type _ directives:DirectiveApplication* _ block:Block {
  return &SlotDecl{
    Name: name.(*Symbol),
    Type_: type_.(TypeNode),
    Directives: sliceOf[*DirectiveApplication](directives),
    Value: block.(*Block),
    Loc: c.Loc(),
  }, nil
}
ArgWithType <- name:IdSymbol _ ColonToken _ type_:Type _ directives:DirectiveApplication* {
  return &SlotDecl{
    Name: name.(*Symbol),
    Type_: type_.(TypeNode),
    Directives: sliceOf[*DirectiveApplication](directives),
    Loc: c.Loc(),
  }, nil
}

Argument <- KeyValue / PositionalValue

KeyValue <- key:WordToken ColonToken _ value:Form {
  return Keyed[Node]{Key: key.(string), Value: value.(Node), Positional: false}, nil
}

PositionalValue <- value:Form {
  return Keyed[Node]{Key: "", Value: value.(Node), Positional: true}, nil
}
ColonToken <- ':'

Type <- NonNull / NamedType / ListType / ObjectType / TypeVariable
NamedType <- name:UpperId {
  return &NamedTypeNode{name.(string), c.Loc()}, nil
}
ListType <- '[' inner:Type ']' {
  return ListTypeNode{inner.(TypeNode)}, nil
}
ObjectType <- "{{" _ fields:(f:ObjectTypeField Sep { return f, nil })* last:ObjectTypeField? _ "}}" {
  return ObjectTypeNode{
    Fields: sliceOfAppend[ObjectTypeField](fields, last),
  }, nil
}
ObjectTypeField <- key:Id _ ColonToken _ type_:Type {
  return ObjectTypeField{
    Key: key.(string),
    Type: type_.(TypeNode),
  }, nil
}
NonNull <- inner:Type BangToken {
  return NonNullTypeNode{inner.(TypeNode)}, nil
}
TypeVariable <- v:[a-z] {
  return VariableTypeNode{v.([]byte)[0]}, nil
}

BangToken <- '!'

// Precedence levels from lowest to highest
DefaultExpr <- left:(EqualityExpr / Term) _ DoubleInterroToken _ right:(DefaultExpr / Term) {
  return &Default{
    Left: left.(Node),
    Right: right.(Node),
    Loc: c.Loc(),
  }, nil
} / EqualityExpr

EqualityExpr <- left:(EqualityExpr / Term) _ op:EqualityOp _ right:(RelationalExpr / Term) {
  switch op.(string) {
  case "==":
    return &Equality{
      Left: left.(Node),
      Right: right.(Node),
      Loc: c.Loc(),
    }, nil
  case "!=":
    return NewInequality(left.(Node), right.(Node), c.Loc()), nil
  default:
    return nil, fmt.Errorf("unknown equality operator: %s", op.(string))
  }
} / RelationalExpr

EqualityOp <- "==" { return "==", nil } / "!=" { return "!=", nil }

RelationalExpr <- left:(RelationalExpr / Term) _ op:RelationalOp _ right:(AdditiveExpr / Term) {
  switch op.(string) {
  case "<":
    return NewLessThan(left.(Node), right.(Node), c.Loc()), nil
  case "<=":
    return NewLessThanEqual(left.(Node), right.(Node), c.Loc()), nil
  case ">":
    return NewGreaterThan(left.(Node), right.(Node), c.Loc()), nil
  case ">=":
    return NewGreaterThanEqual(left.(Node), right.(Node), c.Loc()), nil
  default:
    return nil, fmt.Errorf("unknown relational operator: %s", op.(string))
  }
} / AdditiveExpr

RelationalOp <- "<=" { return "<=", nil } / ">=" { return ">=", nil } / "<" { return "<", nil } / ">" { return ">", nil }

AdditiveExpr <- left:(AdditiveExpr / Term) _ op:AdditiveOp _ right:(MultiplicativeExpr / Term) {
  switch op.(string) {
  case "+":
    return NewAddition(left.(Node), right.(Node), c.Loc()), nil
  case "-":
    return NewSubtraction(left.(Node), right.(Node), c.Loc()), nil
  default:
    return nil, fmt.Errorf("unknown additive operator: %s", op.(string))
  }
} / MultiplicativeExpr

AdditiveOp <- "+" { return "+", nil } / "-" { return "-", nil }

MultiplicativeExpr <- left:(MultiplicativeExpr / Term) _ op:MultiplicativeOp _ right:Term {
  switch op.(string) {
  case "*":
    return NewMultiplication(left.(Node), right.(Node), c.Loc()), nil
  case "/":
    return NewDivision(left.(Node), right.(Node), c.Loc()), nil
  case "%":
    return NewModulo(left.(Node), right.(Node), c.Loc()), nil
  default:
    return nil, fmt.Errorf("unknown multiplicative operator: %s", op.(string))
  }
}

MultiplicativeOp <- "*" { return "*", nil } / "/" { return "/", nil } / "%" { return "%", nil }

DoubleInterroToken <- "??"
ReopenToken <- "<<"

DotToken <- '.'

List <- '[' _ eles:(e:Form Sep { return e, nil })* last:Form? _ ']' {
  return &List{
    Elements: sliceOfAppend[Node](eles, last),
    Loc: c.Loc(),
  }, nil
}

Object <- "{{" _ vals:(v:KeyValue Sep { return v, nil })* last:KeyValue? _ "}}" {
  var slots []*SlotDecl
  for _, kv := range sliceOfAppend[Keyed[Node]](vals, last) {
    slots = append(slots, &SlotDecl{
      Name: &Symbol{
        Name: kv.Key,
        Loc: kv.Value.GetSourceLocation(),
      },
      Value: kv.Value,
      Loc: kv.Value.GetSourceLocation(),
    })
  }
  return &Object{
    Slots: slots,
    Loc: c.Loc(),
  }, nil
}

Block <- '{' _ eles:(e:Expr Sep { return e, nil })* last:Expr? _ '}' {
  return &Block{
    Forms: sliceOfAppend[Node](eles, last),
    Loc: c.Loc(),
  }, nil
}

HeadersBlock <- '{' _ eles:(e:HeaderSlot Sep { return e, nil })* last:HeaderSlot? _ '}' {
  return &Block{
    Forms: sliceOfAppend[Node](eles, last),
    Loc: c.Loc(),
  }, nil
}

// Literals

Literal <- Float / Int / Boolean / TripleQuoteString / String / Quoted / Null

Float <- ((('0' / NonZeroDecimalDigit DecimalDigit*) '.' DecimalDigit+ Exponent?) / (('0' / NonZeroDecimalDigit DecimalDigit+) Exponent)) {
  value, err := strconv.ParseFloat(string(c.text), 64)
  if err != nil {
    return nil, err
  }
  return &Float{
    Value: value,
    Loc: c.Loc(),
  }, nil
}

Int <- ('0' / NonZeroDecimalDigit DecimalDigit*) {
  value, err := strconv.ParseInt(string(c.text), 10, 64)
  if err != nil {
    return nil, err
  }
  return &Int{
    Value: value,
    Loc: c.Loc(),
  }, nil
}

NonZeroDecimalDigit <- [1-9]

DecimalDigit <- [0-9]

Exponent <- 'e'i [+-]? DecimalDigit+

TripleQuoteString <- TripleQuote content:ImmediateTripleQuoteStringContent TripleQuote {
  return &String{
    Value: normalizeTripleQuoteString(content.([]byte)),
    Loc: c.Loc(),
  }, nil
} / TripleQuote TripleQuote {
  return &String{
    Value: "",
    Loc: c.Loc(),
  }, nil
}

ImmediateTripleQuoteStringContent <- ( [^"] / '\n' / '"' '"'? [^"])+ {
  return c.text, nil
}

TripleQuote <- "\"\"\""


String <- '"' ( ImmediateStringContent / ImmediateEscape )* ImmediateQuoteToken {
  c.text = bytes.Replace(c.text, []byte(`\/`), []byte(`/`), -1)
  value, err := strconv.Unquote(string(c.text))
  if err != nil {
    return nil, err
  }
  return &String{
    Value: value,
    Loc: c.Loc(),
  }, nil
}

ImmediateQuoteToken <- '"'
ImmediateStringContent <- [^\\"\n]+
ImmediateEscape <- '\\' (
    [abfnrtv"\\]
  / 'x' [0-9a-f]i [0-9a-f]i
  / 'u' [0-9a-f]i [0-9a-f]i [0-9a-f]i [0-9a-f]i
  / 'U' [0-9a-f]i [0-9a-f]i [0-9a-f]i [0-9a-f]i [0-9a-f]i [0-9a-f]i [0-9a-f]i [0-9a-f]i
  / [0-7] [0-7] [0-7]
)

DocString <- TripleQuote content:ImmediateTripleQuoteStringContent TripleQuote {
  return normalizeDocString(content.([]byte)), nil
} / TripleQuote TripleQuote {
  return "", nil
}

Quoted <- '%' quoter:WordToken '{' raw:QuotedRawToken '}' {
  return &Quoted{
    Quoter: quoter.(string),
    Raw:    raw.(string),
  }, nil
}
QuotedRawToken <- [^}]* {
  return string(c.text), nil
}

Boolean <- TrueToken {
  return &Boolean{
    Value: true,
    Loc: c.Loc(),
  }, nil
} / FalseToken {
  return &Boolean{
    Value: false,
    Loc: c.Loc(),
  }, nil
}
TrueToken <- "true" !WordChar
FalseToken <- "false" !WordChar

Null <- NullToken {
  return &Null{
    Loc: c.Loc(),
  }, nil
}
NullToken <- "null" !WordChar

CommentToken <- '#' [^\n]*

// Additional language constructs

Conditional <- IfToken _ cond:Form _ block:Block else_:ElseClause? {
  return &Conditional{
    Condition: cond.(Node),
    Then: block.(*Block),
    Else: else_,
    Loc: c.Loc(),
  }, nil
}

ElseClause <- _ ElseToken _ elseif:Conditional {
  // else if - wrap the conditional in a block
  return &Block{
    Forms: []Node{elseif.(Node)},
    Loc: elseif.(Node).GetSourceLocation(),
  }, nil
} / _ ElseToken _ block:Block {
  return block.(*Block), nil
}

IfToken <- "if" !WordChar
ElseToken <- "else" !WordChar

ForLoop <- ForTwoVarLoop / ForSingleVarLoop / ForConditionLoop / ForInfiniteLoop

ForSingleVarLoop <- ForToken _ variable:Id typeAnnotation:(_ ColonToken _ t:Type)? _ InToken _ iterable:Form _ body:Block {
  var varType TypeNode
  if typeAnnotation != nil {
    varType = typeAnnotation.([]interface{})[2].(TypeNode)
  }
  return &ForLoop{
    Variable: variable.(string),
    Type: varType,
    Iterable: iterable.(Node),
    LoopBody: body.(*Block),
    Loc: c.Loc(),
  }, nil
}

ForTwoVarLoop <- ForToken _ key:Id _ CommaToken _ value:Id _ InToken _ iterable:Form _ body:Block {
  return &ForLoop{
    KeyVariable: key.(string),
    ValueVariable: value.(string),
    Iterable: iterable.(Node),
    LoopBody: body.(*Block),
    Loc: c.Loc(),
  }, nil
}

ForConditionLoop <- ForToken _ cond:Form _ body:Block {
  return &ForLoop{
    Condition: cond.(Node),
    LoopBody: body.(*Block),
    Loc: c.Loc(),
  }, nil
}

ForInfiniteLoop <- ForToken _ body:Block {
  return &ForLoop{
    LoopBody: body.(*Block),
    Loc: c.Loc(),
  }, nil
}

ForToken <- "for" !WordChar
InToken <- "in" !WordChar

Lambda <- LambdaToken args:LambdaArgs _ ArrowToken _ expr:Form {
  return &Lambda{
    FunctionBase: FunctionBase{
      Args: args.([]*SlotDecl),
      Body: expr.(Node),
      Loc: c.Loc(),
    },
  }, nil
}
LambdaToken <- '\\'
ArrowToken <- "->"

LambdaArgs <- '(' _ args:(a:LambdaArg Sep { return a, nil })* last:LambdaArg? _ ')' {
  return sliceOfAppend[*SlotDecl](args, last), nil
} / arg:LambdaArg {
  return []*SlotDecl{arg.(*SlotDecl)}, nil
}

LambdaArg <- ArgWithDefault / ArgWithBlockDefault / ArgWithType / ArgWithoutType

ArgWithoutType <- name:IdSymbol {
  return &SlotDecl{
    Name: name.(*Symbol),
    Loc: c.Loc(),
  }, nil
}

Match <- MatchToken _ expr:Form _ WithToken _ '{' _ cs:(m:MatchCase Sep { return m, nil })* last:MatchCase? _ '}' {
  return &Match{
    Expr: expr.(Node),
    Cases: sliceOfAppend[*MatchCase](cs, last),
    Loc: c.Loc(),
  }, nil
}

MatchCase <- pattern:Pattern _ "->" _ expr:Form {
  return &MatchCase{
    Pattern: pattern.(Pattern),
    Expr: expr.(Node),
    Loc: c.Loc(),
  }, nil
}

Pattern <- WildcardPattern / LiteralPattern / ConstructorPattern / VariablePattern

WildcardPattern <- '_' {
  return WildcardPattern{}, nil
}

LiteralPattern <- lit:Literal {
  return LiteralPattern{Value: lit.(Node)}, nil
}

ConstructorPattern <- name:UpperId args:PatternArgs? {
  var patterns []Pattern
  if args != nil {
    patterns = args.([]Pattern)
  }
  return ConstructorPattern{
    Name: name.(string),
    Args: patterns,
  }, nil
}

PatternArgs <- '(' _ patterns:(p:Pattern Sep { return p, nil })* last:Pattern? _ ')' {
  return sliceOfAppend[Pattern](patterns, last), nil
}

VariablePattern <- name:Id {
  return VariablePattern{Name: name.(string)}, nil
}

MatchToken <- "match" !WordChar
WithToken <- "with" !WordChar

Assert <- AssertToken message:MessageArgs? _ block:Block {
  var msg Node
  if message != nil {
    msg = message.(Node)
  }
  return &Assert{
    Message: msg,
    Block: block.(*Block),
    Loc: c.Loc(),
  }, nil
}

MessageArgs <- '(' _ msg:Form _ ')' {
  return msg, nil
}

AssertToken <- "assert" !WordChar

Break <- BreakToken {
  return &Break{
    Loc: c.Loc(),
  }, nil
}

BreakToken <- "break" !WordChar

Continue <- ContinueToken {
  return &Continue{
    Loc: c.Loc(),
  }, nil
}

ContinueToken <- "continue" !WordChar

Reassignment <- target:Term _ op:AssignOp _ value:Form {
  return &Reassignment{
    Target: target.(Node),
    Modifier: op.(string),
    Value: value.(Node),
    Loc: c.Loc(),
  }, nil
}

AssignOp <- PlusEqualToken { return "+", nil } / EqualToken { return "=", nil }
PlusEqualToken <- "+="
EqualToken <- '='

TypeHint <- expr:Term _ DoubleColonToken _ type_:Type {
  return &TypeHint{
    Expr: expr.(Node),
    Type: type_.(TypeNode),
    Loc: c.Loc(),
  }, nil
}

DoubleColonToken <- "::"

Reopen <- name:Id _ ReopenToken _ b:Block {
  return &Reopen{
    Name: name.(string),
    Block: b.(*Block),
    Loc: c.Loc(),
  }, nil
}

DirectiveDecl <- DirectiveToken _ name:DirectiveName _ args:ArgTypes? _ OnToken _ locations:DirectiveLocations {
  var argTypes []*SlotDecl
  if args != nil {
    argTypes = args.([]*SlotDecl)
  }
  return &DirectiveDecl{
    Name: name.(string),
    Args: argTypes,
    Locations: locations.([]DirectiveLocation),
    Loc: c.Loc(),
  }, nil
}

DirectiveApplication <- '@' name:Id args:ArgValues? {
  var argValues []Keyed[Node]
  if args != nil {
    argValues = args.([]Keyed[Node])
  }
  return &DirectiveApplication{
    Name: name.(string),
    Args: argValues,
    Loc: c.Loc(),
  }, nil
}

DirectiveLocations <- first:DirectiveLocation rest:(_ '|' _ loc:DirectiveLocation { return loc, nil })* {
  return sliceOfAppend[DirectiveLocation](rest, first), nil
}

DirectiveLocation <- name:UpperId {
  return DirectiveLocation{Name: name.(string)}, nil
}

DirectiveName <- '@' name:Id {
  return name.(string), nil
}

DirectiveToken <- "directive" !WordChar
OnToken <- "on" !WordChar

Import <- ImportToken _ source:ImportSource alias:(_ AsToken _ name:Id)? {
  var aliasStr *string
  if alias != nil {
    // alias is [_, "as", _, string]
    aliasValue := alias.([]interface{})[3].(string)
    aliasStr = &aliasValue
  }
  return &ImportDecl{
    Source: source.(string),
    Alias:  aliasStr,
    Loc:    c.Loc(),
  }, nil
}

ImportSource <- DaggerKeyword / SchemaURL
DaggerKeyword <- "dagger" !WordChar {
  return "dagger", nil
}
SchemaURL <- [a-zA-Z] [a-zA-Z0-9.-/]* {
  return string(c.text), nil
}

ImportToken <- "import" !WordChar
AsToken <- "as" !WordChar
