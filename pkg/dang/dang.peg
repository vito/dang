{
  package dang

  import (
    "fmt"
    "strconv"
    "bytes"
    "strings"
  )
}

Dang <- _ eles:(e:Expr Sep { return e, nil })* last:Expr? _ !. {
  return &ModuleBlock{
    Forms: sliceOfAppend[Node](eles, last),
    Loc: c.Loc(),
  }, nil
}

_ "whitespace" <- ([ \t\r\n] / CommentToken)*
_lineSpace <- [ \t]* CommentToken?

Sep <- (_ CommaToken / _lineSpace '\n') _
CommaToken <- ','

Expr <- Import / Decl / Reassignment / Form

Decl <- docstring:DocString? decl:(Interface / Union / Enum / Scalar / Class / NewConstructor / Slot / DirectiveDecl) {
  switch node := decl.(type) {
  case *InterfaceDecl:
    if docstring != nil {
      node.DocString = docstring.(string)
    }
    return node, nil
  case *UnionDecl:
    if docstring != nil {
      node.DocString = docstring.(string)
    }
    return node, nil
  case *EnumDecl:
    if docstring != nil {
      node.DocString = docstring.(string)
    }
    return node, nil
  case *ScalarDecl:
    if docstring != nil {
      node.DocString = docstring.(string)
    }
    return node, nil
  case *ClassDecl:
    if docstring != nil {
      node.DocString = docstring.(string)
    }
    return node, nil
  case *SlotDecl:
    if docstring != nil {
      node.DocString = docstring.(string)
    }
    return node, nil
  case *DirectiveDecl:
    if docstring != nil {
      node.DocString = docstring.(string)
    }
    return node, nil
  case *NewConstructorDecl:
    if docstring != nil {
      node.DocString = docstring.(string)
    }
    return node, nil
  default:
    return decl, nil
  }
}

Form <- TryCatch / Raise / Conditional / ForLoop / Case / Assert / Break / Continue / DefaultExpr / TypeHint / Term

Term <- UnaryExpr / IndexOrCall / SelectOrCall / Literal / List / Object / Block / ParenForm / SymbolOrCall

UnaryExpr <- '!' _ expr:Term {
  return &UnaryNegation{
    Expr: expr.(Node),
    Loc: c.Loc(),
  }, nil
}

ParenForm <- '(' _ expr:Form _ ')' {
  return &Grouped{
    Expr: expr.(Node),
    Loc: c.Loc(),
  }, nil
}

// Handle Symbol followed by optional ()
SymbolOrCall <- Call / SymbolBlock / AutoCallSymbol
Call <- name:Symbol args:ArgValues blockArg:(_ b:BlockArg { return b, nil })? {
  // Symbol followed by () - create FunCall
  argRecord := Record(args.([]Keyed[Node]))

  var block *BlockArg
  if blockArg != nil {
    block = blockArg.(*BlockArg)
  }

  return &FunCall{
    Fun: name.(*Symbol),
    Args: argRecord,
    BlockArg: block,
    Loc: c.Loc(),
  }, nil
}
SymbolBlock <- name:Symbol _ blockArg:BlockArg {
  return &FunCall{
    Fun: name.(*Symbol),
    Args: nil,
    BlockArg: blockArg.(*BlockArg),
    Loc: c.Loc(),
  }, nil
}
AutoCallSymbol <- name:Id {
  return &Symbol{
    Name: name.(string),
    AutoCall: true,
    Loc: c.Loc(),
  }, nil
}

// Handle Select followed by optional (), or ObjectSelection
SelectOrCall <- left:Term _ DotToken _ selection:(ObjectSelection / name:FieldId args:ArgValues? blockArg:(_ b:BlockArg { return b, nil })?) {
  switch sel := selection.(type) {
  case *ObjectSelection:
    // Object selection: obj.{field1, field2}
    sel.Receiver = left.(Node)
    return sel, nil
  case []interface{}:
    // Regular field access with optional args
    name := sel[0].(*Symbol)
    args := sel[1]
    blockArg := sel[2]
    if args != nil || blockArg != nil {
      // Select followed by () and/or block - create FunCall
      var argRecord Record
      if args != nil {
        argRecord = Record(args.([]Keyed[Node]))
      }

      var block *BlockArg
      if blockArg != nil {
        block = blockArg.(*BlockArg)
      }

      return &FunCall{
        Fun: &Select{
          Receiver: left.(Node),
          Field:    name,
          Loc:      c.Loc(),
        },
        Args: argRecord,
        BlockArg: block,
        Loc:  c.Loc(),
      }, nil
    } else {
      // Just a Select
      return &Select{
        Receiver: left.(Node),
        Field:    name,
        AutoCall: true,
        Loc:      c.Loc(),
      }, nil
    }
  default:
    return nil, fmt.Errorf("unexpected selection type")
  }
}

// Handle indexing operations like foo[0]
IndexOrCall <- left:Term ImmediateBracket _ index:Form _ ']' args:ArgValues? {
  if args != nil {
    // Index followed by () - create FunCall
    argRecord := Record(args.([]Keyed[Node]))
    return &FunCall{
      Fun: &Index{
        Receiver: left.(Node),
        Index:    index.(Node),
        Loc:      c.Loc(),
      },
      Args: argRecord,
      Loc:  c.Loc(),
    }, nil
  } else {
    // Just an Index
    return &Index{
      Receiver: left.(Node),
      Index:    index.(Node),
      AutoCall: true,
      Loc:      c.Loc(),
    }, nil
  }
}
ImmediateBracket <- '['

ObjectSelection <- '{' _ first:InlineFragment rest:(Sep f:InlineFragment { return f, nil })* _ '}' {
  return &ObjectSelection{
    Receiver: nil,
    InlineFragments: sliceOfPrepend[*InlineFragment](first, rest),
    Loc: c.Loc(),
  }, nil
} / '{' _ fields:(f:FieldSelection Sep { return f, nil })* last:FieldSelection? _ '}' {
  return &ObjectSelection{
    Receiver: nil, // Will be set by parent SelectOrCall
    Fields: sliceOfAppend[*FieldSelection](fields, last),
    Loc: c.Loc(),
  }, nil
}

InlineFragment <- SpreadToken _ OnToken _ typeName:Symbol _ '{' _ fields:(f:FieldSelection Sep { return f, nil })* last:FieldSelection? _ '}' {
  return &InlineFragment{
    TypeName: typeName.(*Symbol),
    Fields:   sliceOfAppend[*FieldSelection](fields, last),
    Loc:      c.Loc(),
  }, nil
}

SpreadToken <- "..."

FieldSelection <- name:Id args:ArgValues? selection:('.' sel:ObjectSelection)? {
  var argRecord Record
  if args != nil {
    argRecord = Record(args.([]Keyed[Node]))
  }

  if selection != nil {
    return &FieldSelection{
      Name: name.(string),
      Args: argRecord,
      Selection: selection.([]interface{})[1].(*ObjectSelection),
      Loc: c.Loc(),
    }, nil
  } else {
    return &FieldSelection{
      Name: name.(string),
      Args: argRecord,
      Selection: nil,
      Loc: c.Loc(),
    }, nil
  }
}

Interface <- InterfaceToken _ name:Symbol _ block:HeadersBlock {
  return &InterfaceDecl{
    Name: name.(*Symbol),
    Value: block.(*Block),
    Visibility: PublicVisibility,
    Loc: c.Loc(),
  }, nil
}
InterfaceToken <- "interface" !WordChar

Union <- UnionToken _ name:Symbol _ '=' _ first:Symbol rest:(_ '|' _ s:Symbol { return s, nil })* {
  return &UnionDecl{
    Name:       name.(*Symbol),
    Members:    sliceOfPrepend[*Symbol](first, rest),
    Visibility: PublicVisibility,
    Loc:        c.Loc(),
  }, nil
}
UnionToken <- "union" !WordChar

Class <- prefixDirectives:(d:PrefixDirectiveApplication _ { return d, nil })* TypeToken _ name:Symbol implements:(_ i:Implements { return i, nil })? suffixDirectives:DirectiveApplication* _ block:Block {
  return &ClassDecl{
    Name: name.(*Symbol),
    Value: block.(*Block),
    Implements: sliceOf[*Symbol](implements),
    Visibility: PublicVisibility, // TODO
    Directives: append(sliceOf[*DirectiveApplication](prefixDirectives), sliceOf[*DirectiveApplication](suffixDirectives)...),
    Loc: c.Loc(),
  }, nil
}
TypeToken <- "type" !WordChar
Implements <-  ImplementsToken _ first:Symbol rest:(_ AmpersandToken _ i:Symbol { return i, nil })* {
  return sliceOfPrepend[*Symbol](first, rest), nil
}
ImplementsToken <- "implements" !WordChar

AmpersandToken <- '&'

Enum <- EnumToken _ name:Symbol _ '{' _ values:(first:CapsSymbol rest:(_ v:CapsSymbol { return v, nil })* { return sliceOfPrepend[*Symbol](first, rest), nil }) _ '}' {
  return &EnumDecl{
    Name: name.(*Symbol),
    Values: values.([]*Symbol),
    Visibility: PublicVisibility,
    Loc: c.Loc(),
  }, nil
}
EnumToken <- "enum" !WordChar

Scalar <- ScalarToken _ name:Symbol {
  return &ScalarDecl{
    Name: name.(*Symbol),
    Visibility: PublicVisibility,
    Loc: c.Loc(),
  }, nil
}
ScalarToken <- "scalar" !WordChar

NewConstructor <- NewToken _ args:ArgTypes _ block:Block {
  return &NewConstructorDecl{
    Args: args.([]*SlotDecl),
    BodyBlock: block.(*Block),
    Loc: c.Loc(),
  }, nil
} / NewToken _ block:Block {
  return &NewConstructorDecl{
    Args: nil,
    BodyBlock: block.(*Block),
    Loc: c.Loc(),
  }, nil
}
NewToken <- "new" !WordChar

Slot <- TypeAndArgsAndBlockSlot  // pub a(foo: Boolean!): Int! { 1 }
      / TypeAndBlockSlot         // pub a: Int! { 1 }  <- becomes a function that takes an empty record of args, can use other fields
      / TypeAndValueSlot         // pub a: Int! = 1    <- no longer required, default pre-initialized (don't need to worry about mutation)
      / ValueOnlySlot            // pub a = 1              <- as above, type inferred as Int!
      / TypeOnlySlot             // pub a: Int              <- as above, type inferred as Int!

TypeAndValueSlot <- prefixDirectives:(d:PrefixDirectiveApplication _ { return d, nil })* vis:Visibility _ name:Symbol _ ColonToken _ type_:Type suffixDirectives:DirectiveApplication* _ EqualToken _ value:Form {
  return &SlotDecl{
    Name: name.(*Symbol),
    Type_: type_.(TypeNode),
    Value: value.(Node),
    Visibility: vis.(Visibility),
    Directives: append(sliceOf[*DirectiveApplication](prefixDirectives), sliceOf[*DirectiveApplication](suffixDirectives)...),
    Loc: c.Loc(),
  }, nil
}

ValueOnlySlot <- prefixDirectives:(d:PrefixDirectiveApplication _ { return d, nil })* vis:Visibility _ name:Symbol suffixDirectives:DirectiveApplication* _ EqualToken _ val:Form {
  return &SlotDecl{
    Name: name.(*Symbol),
    Value: val.(Node),
    Visibility: vis.(Visibility),
    Directives: append(sliceOf[*DirectiveApplication](prefixDirectives), sliceOf[*DirectiveApplication](suffixDirectives)...),
    Loc: c.Loc(),
  }, nil
}

TypeOnlySlot <- prefixDirectives:(d:PrefixDirectiveApplication _ { return d, nil })* vis:Visibility _ name:Symbol _ ColonToken _ type_:Type suffixDirectives:DirectiveApplication* {
  return &SlotDecl{
    Name: name.(*Symbol),
    Type_: type_.(TypeNode),
    Visibility: vis.(Visibility),
    Directives: append(sliceOf[*DirectiveApplication](prefixDirectives), sliceOf[*DirectiveApplication](suffixDirectives)...),
    Loc: c.Loc(),
  }, nil
}

TypeAndBlockSlot <- prefixDirectives:(d:PrefixDirectiveApplication _ { return d, nil })* vis:Visibility _ name:Symbol _ ColonToken _ type_:Type suffixDirectives:DirectiveApplication* _ block:Block {
  allDirectives := append(sliceOf[*DirectiveApplication](prefixDirectives), sliceOf[*DirectiveApplication](suffixDirectives)...)
  return &SlotDecl{
    Name: name.(*Symbol),
    Type_: FunTypeNode{nil, type_.(TypeNode)},
    Value: &FunDecl{
      FunctionBase: FunctionBase{
        Args: nil,
        Body: block.(*Block),
        Directives: allDirectives,
        Loc: c.Loc(),
      },
      Named: name.(*Symbol).Name,
      Ret: type_.(TypeNode),
      Visibility: vis.(Visibility),
    },
    Visibility: vis.(Visibility),
    Directives: allDirectives,
    Loc: c.Loc(),
  }, nil
}

TypeAndArgsAndBlockSlot <- prefixDirectives:(d:PrefixDirectiveApplication _ { return d, nil })* vis:Visibility _ name:Symbol _ args:ArgTypes _ ColonToken _ type_:Type suffixDirectives:DirectiveApplication* _ block:Block {
  // Separate block parameters from regular arguments
  allArgs := args.([]*SlotDecl)
  var regularArgs []*SlotDecl
  var blockParam *SlotDecl

  for _, arg := range allArgs {
    if arg.IsBlockParam {
      if blockParam != nil {
        return nil, fmt.Errorf("function can only have one block parameter")
      }
      blockParam = arg
    } else {
      regularArgs = append(regularArgs, arg)
    }
  }

  allDirectives := append(sliceOf[*DirectiveApplication](prefixDirectives), sliceOf[*DirectiveApplication](suffixDirectives)...)

  return &SlotDecl{
    Name: name.(*Symbol),
    Type_: FunTypeNode{allArgs, type_.(TypeNode)},
    Value: &FunDecl{
      FunctionBase: FunctionBase{
        Args: regularArgs,
        BlockParam: blockParam,
        Body: block.(*Block),
        Directives: allDirectives,
        Loc: c.Loc(),
      },
      Named: name.(*Symbol).Name,
      Ret: type_.(TypeNode),
      Visibility: vis.(Visibility),
    },
    Visibility: vis.(Visibility),
    Directives: allDirectives,
    Loc: c.Loc(),
  }, nil
}

HeaderSlot <- docstring:DocString? slot:(TypeAndArgsSlot / TypeOnlyFunSlot) {
  if docstring != nil {
    slot.(*SlotDecl).DocString = docstring.(string)
  }
  return slot, nil
}

TypeAndArgsSlot <- prefixDirectives:(d:PrefixDirectiveApplication _ { return d, nil })* vis:Visibility _ name:Symbol _ args:ArgTypes _ ColonToken _ type_:Type suffixDirectives:DirectiveApplication* {
  return &SlotDecl{
    Name: name.(*Symbol),
    Type_: FunTypeNode{args.([]*SlotDecl), type_.(TypeNode)},
    Visibility: vis.(Visibility),
    Directives: append(sliceOf[*DirectiveApplication](prefixDirectives), sliceOf[*DirectiveApplication](suffixDirectives)...),
    Loc: c.Loc(),
  }, nil
}

TypeOnlyFunSlot <- prefixDirectives:(d:PrefixDirectiveApplication _ { return d, nil })* vis:Visibility _ name:Symbol _ ColonToken _ type_:Type suffixDirectives:DirectiveApplication* {
  return &SlotDecl{
    Name: name.(*Symbol),
    Type_: FunTypeNode{nil, type_.(TypeNode)},
    Visibility: vis.(Visibility),
    Directives: append(sliceOf[*DirectiveApplication](prefixDirectives), sliceOf[*DirectiveApplication](suffixDirectives)...),
    Loc: c.Loc(),
  }, nil
}

Visibility <- PubToken { return PublicVisibility, nil }
            / LetToken { return PrivateVisibility, nil }
PubToken <- "pub" !WordChar
LetToken <- "let" !WordChar

Symbol <- name:Id {
  return &Symbol{
    Name: name.(string),
    Loc: c.Loc(),
  }, nil
}
Id <- WordToken
FieldId <- !NullToken [a-zA-Z_][a-zA-Z0-9_]* {
  return &Symbol{
    Name: string(c.text),
    Loc: c.Loc(),
  }, nil
}
WordToken <- !NullToken [a-zA-Z_][a-zA-Z0-9_]* {
  return string(c.text), nil
}
WordChar <- [a-zA-Z0-9_]
UpperId <- UpperToken
UpperToken <- [A-Z][a-zA-Z0-9_]* {
  return string(c.text), nil
}
CapsSymbol <- name:CapsToken {
  return &Symbol{
    Name: name.(string),
    Loc: c.Loc(),
  }, nil
}
CapsToken <- [A-Z][A-Z0-9_]* {
  return string(c.text), nil
}

ImmediateParen <- '('
ArgValues <- ImmediateParen _ args:(a:Argument Sep { return a, nil })* last:Argument? _ ')' {
  return sliceOfAppend[Keyed[Node]](args, last), nil
}
ArgTypes <- ImmediateParen _ args:(a:ArgType Sep { return a, nil })* last:ArgType? _ ')' {
  return sliceOfAppend[*SlotDecl](args, last), nil
}
ArgType <- docstring:DocString _ slot:(ArgWithDefault / ArgWithBlockDefault / ArgWithType / BlockParamDecl) {
  slotDecl := slot.(*SlotDecl)
  return &SlotDecl{
    Name: slotDecl.Name,
    Type_: slotDecl.Type_,
    Value: slotDecl.Value,
    Directives: slotDecl.Directives,
    DocString: docstring.(string),
    IsBlockParam: slotDecl.IsBlockParam,
    Loc: slotDecl.Loc,
  }, nil
} / slot:(ArgWithDefault / ArgWithBlockDefault / ArgWithType / BlockParamDecl) {
  return slot.(*SlotDecl), nil
}
ArgWithDefault <- prefixDirectives:(d:PrefixDirectiveApplication _ { return d, nil })* name:Symbol _ ColonToken _ type_:Type suffixDirectives:DirectiveApplication* _ EqualToken _ value:Form {
  return &SlotDecl{
    Name: name.(*Symbol),
    Type_: type_.(TypeNode),
    Directives: append(sliceOf[*DirectiveApplication](prefixDirectives), sliceOf[*DirectiveApplication](suffixDirectives)...),
    Value: value.(Node),
    Loc: c.Loc(),
  }, nil
}
ArgWithBlockDefault <- prefixDirectives:(d:PrefixDirectiveApplication _ { return d, nil })* name:Symbol _ ColonToken _ type_:Type suffixDirectives:DirectiveApplication* _ block:Block {
  return &SlotDecl{
    Name: name.(*Symbol),
    Type_: type_.(TypeNode),
    Directives: append(sliceOf[*DirectiveApplication](prefixDirectives), sliceOf[*DirectiveApplication](suffixDirectives)...),
    Value: block.(*Block),
    Loc: c.Loc(),
  }, nil
}
ArgWithType <- prefixDirectives:(d:PrefixDirectiveApplication _ { return d, nil })* name:Symbol _ ColonToken _ type_:Type suffixDirectives:DirectiveApplication* {
  return &SlotDecl{
    Name: name.(*Symbol),
    Type_: type_.(TypeNode),
    Directives: append(sliceOf[*DirectiveApplication](prefixDirectives), sliceOf[*DirectiveApplication](suffixDirectives)...),
    Loc: c.Loc(),
  }, nil
}
BlockParamDecl <- AmpersandToken name:Symbol _ args:ArgTypes? _ ColonToken _ ret:Type {
  var argTypes []*SlotDecl
  if args != nil {
    argTypes = args.([]*SlotDecl)
  }
  return &SlotDecl{
    Name: name.(*Symbol),
    Type_: FunTypeNode{argTypes, ret.(TypeNode)},
    IsBlockParam: true,
    Loc: c.Loc(),
  }, nil
}

Argument <- KeyValue / PositionalValue

KeyValue <- key:WordToken ColonToken _ value:Form {
  return Keyed[Node]{Key: key.(string), Value: value.(Node), Positional: false}, nil
}

PositionalValue <- value:Form {
  return Keyed[Node]{Key: "", Value: value.(Node), Positional: true}, nil
}
ColonToken <- ':'

Type <- NonNull / NamedType / ListType / ObjectType / TypeVariable
NamedType <- qual:(n:NamedType DotToken { return n, nil })? name:UpperId {
  var base *NamedTypeNode
  if qual != nil {
    base = qual.(*NamedTypeNode)
  }
  return &NamedTypeNode{
    Base: base,
    Name: name.(string),
    Loc: c.Loc(),
  }, nil
}
ListType <- '[' inner:Type ']' {
  return ListTypeNode{inner.(TypeNode)}, nil
}
ObjectType <- "{{" _ fields:(f:ObjectTypeField Sep { return f, nil })* last:ObjectTypeField? _ "}}" {
  return ObjectTypeNode{
    Fields: sliceOfAppend[ObjectTypeField](fields, last),
  }, nil
}
ObjectTypeField <- key:Id _ ColonToken _ type_:Type {
  return ObjectTypeField{
    Key: key.(string),
    Type: type_.(TypeNode),
  }, nil
}
NonNull <- inner:Type BangToken {
  return NonNullTypeNode{inner.(TypeNode)}, nil
}
TypeVariable <- v:[a-z] {
  return VariableTypeNode{v.([]byte)[0]}, nil
}

BangToken <- '!'

// Precedence levels from lowest to highest
DefaultExpr <- left:(LogicalOrExpr / Term) _ DoubleInterroToken _ right:(DefaultExpr / Term) {
  return &Default{
    Left: left.(Node),
    Right: right.(Node),
    Loc: c.Loc(),
  }, nil
} / LogicalOrExpr

LogicalOrExpr <- left:(LogicalOrExpr / Term) _ OrToken _ right:(LogicalAndExpr / Term) {
  return &LogicalOr{
    Left: left.(Node),
    Right: right.(Node),
    Loc: c.Loc(),
  }, nil
} / LogicalAndExpr

LogicalAndExpr <- left:(LogicalAndExpr / Term) _ AndToken _ right:(EqualityExpr / Term) {
  return &LogicalAnd{
    Left: left.(Node),
    Right: right.(Node),
    Loc: c.Loc(),
  }, nil
} / EqualityExpr

EqualityExpr <- left:(EqualityExpr / Term) _ op:EqualityOp _ right:(RelationalExpr / Term) {
  switch op.(string) {
  case "==":
    return &Equality{
      Left: left.(Node),
      Right: right.(Node),
      Loc: c.Loc(),
    }, nil
  case "!=":
    return NewInequality(left.(Node), right.(Node), c.Loc()), nil
  default:
    return nil, fmt.Errorf("unknown equality operator: %s", op.(string))
  }
} / RelationalExpr

EqualityOp <- "==" { return "==", nil } / "!=" { return "!=", nil }

RelationalExpr <- left:(RelationalExpr / Term) _ op:RelationalOp _ right:(AdditiveExpr / Term) {
  switch op.(string) {
  case "<":
    return NewLessThan(left.(Node), right.(Node), c.Loc()), nil
  case "<=":
    return NewLessThanEqual(left.(Node), right.(Node), c.Loc()), nil
  case ">":
    return NewGreaterThan(left.(Node), right.(Node), c.Loc()), nil
  case ">=":
    return NewGreaterThanEqual(left.(Node), right.(Node), c.Loc()), nil
  default:
    return nil, fmt.Errorf("unknown relational operator: %s", op.(string))
  }
} / AdditiveExpr

RelationalOp <- "<=" { return "<=", nil } / ">=" { return ">=", nil } / "<" { return "<", nil } / ">" { return ">", nil }

AdditiveExpr <- left:(AdditiveExpr / Term) _ op:AdditiveOp _ right:(MultiplicativeExpr / Term) {
  switch op.(string) {
  case "+":
    return NewAddition(left.(Node), right.(Node), c.Loc()), nil
  case "-":
    return NewSubtraction(left.(Node), right.(Node), c.Loc()), nil
  default:
    return nil, fmt.Errorf("unknown additive operator: %s", op.(string))
  }
} / MultiplicativeExpr

AdditiveOp <- "+" { return "+", nil } / "-" { return "-", nil }

MultiplicativeExpr <- left:(MultiplicativeExpr / Term) _ op:MultiplicativeOp _ right:Term {
  switch op.(string) {
  case "*":
    return NewMultiplication(left.(Node), right.(Node), c.Loc()), nil
  case "/":
    return NewDivision(left.(Node), right.(Node), c.Loc()), nil
  case "%":
    return NewModulo(left.(Node), right.(Node), c.Loc()), nil
  default:
    return nil, fmt.Errorf("unknown multiplicative operator: %s", op.(string))
  }
}

MultiplicativeOp <- "*" { return "*", nil } / "/" { return "/", nil } / "%" { return "%", nil }

DoubleInterroToken <- "??"

DotToken <- '.'

List <- '[' _ eles:(e:Form Sep { return e, nil })* last:Form? _ ']' {
  return &List{
    Elements: sliceOfAppend[Node](eles, last),
    Loc: c.Loc(),
  }, nil
}

Object <- "{{" _ vals:(v:KeyValue Sep { return v, nil })* last:KeyValue? _ "}}" {
  var slots []*SlotDecl
  for _, kv := range sliceOfAppend[Keyed[Node]](vals, last) {
    slots = append(slots, &SlotDecl{
      Name: &Symbol{
        Name: kv.Key,
        Loc: kv.Value.GetSourceLocation(),
      },
      Value: kv.Value,
      Loc: kv.Value.GetSourceLocation(),
    })
  }
  return &Object{
    Slots: slots,
    Loc: c.Loc(),
  }, nil
}

Block <- '{' _ eles:(e:Expr Sep { return e, nil })* last:Expr? _ '}' {
  return &Block{
    Forms: sliceOfAppend[Node](eles, last),
    Loc: c.Loc(),
  }, nil
}


HeadersBlock <- '{' _ eles:(e:HeaderSlot Sep { return e, nil })* last:HeaderSlot? _ '}' {
  return &Block{
    Forms: sliceOfAppend[Node](eles, last),
    Loc: c.Loc(),
  }, nil
}

// Literals

Literal <- Float / Int / Boolean / TripleQuoteString / String / Quoted / Null / SelfKeyword

Float <- ((('0' / NonZeroDecimalDigit DecimalDigit*) '.' DecimalDigit+ Exponent?) / (('0' / NonZeroDecimalDigit DecimalDigit+) Exponent)) {
  value, err := strconv.ParseFloat(string(c.text), 64)
  if err != nil {
    return nil, err
  }
  return &Float{
    Value: value,
    Text:  string(c.text),
    Loc:   c.Loc(),
  }, nil
}

Int <- ('0' / NonZeroDecimalDigit DecimalDigit*) {
  value, err := strconv.ParseInt(string(c.text), 10, 64)
  if err != nil {
    return nil, err
  }
  return &Int{
    Value: value,
    Loc: c.Loc(),
  }, nil
}

NonZeroDecimalDigit <- [1-9]

DecimalDigit <- [0-9]

Exponent <- 'e'i [+-]? DecimalDigit+

TripleQuoteString <- TripleQuote content:ImmediateTripleQuoteStringContent TripleQuote {
  return &String{
    Value:        normalizeTripleQuoteString(content.([]byte)),
    TripleQuoted: true,
    Loc:          c.Loc(),
  }, nil
} / TripleQuote TripleQuote {
  return &String{
    Value:        "",
    TripleQuoted: true,
    Loc:          c.Loc(),
  }, nil
}

ImmediateTripleQuoteStringContent <- ( [^"] / '\n' / '"' '"'? [^"])+ {
  return c.text, nil
}

TripleQuote <- "\"\"\""


String <- '"' ( ImmediateStringContent / ImmediateEscape )* ImmediateQuoteToken {
  c.text = bytes.Replace(c.text, []byte(`\/`), []byte(`/`), -1)
  value, err := strconv.Unquote(string(c.text))
  if err != nil {
    return nil, err
  }
  return &String{
    Value: value,
    Loc: c.Loc(),
  }, nil
}

ImmediateQuoteToken <- '"'
ImmediateStringContent <- [^\\"\n]+
ImmediateEscape <- '\\' (
    [abfnrtv"\\]
  / 'x' [0-9a-f]i [0-9a-f]i
  / 'u' [0-9a-f]i [0-9a-f]i [0-9a-f]i [0-9a-f]i
  / 'U' [0-9a-f]i [0-9a-f]i [0-9a-f]i [0-9a-f]i [0-9a-f]i [0-9a-f]i [0-9a-f]i [0-9a-f]i
  / [0-7] [0-7] [0-7]
)

DocString <- TripleQuote content:ImmediateTripleQuoteStringContent TripleQuote _ {
  return normalizeTripleQuoteString(content.([]byte)), nil
} / TripleQuote TripleQuote {
  return "", nil
}

Quoted <- '%' quoter:WordToken '{' raw:QuotedRawToken '}' {
  return &Quoted{
    Quoter: quoter.(string),
    Raw:    raw.(string),
  }, nil
}
QuotedRawToken <- [^}]* {
  return string(c.text), nil
}

Boolean <- TrueToken {
  return &Boolean{
    Value: true,
    Loc: c.Loc(),
  }, nil
} / FalseToken {
  return &Boolean{
    Value: false,
    Loc: c.Loc(),
  }, nil
}
TrueToken <- "true" !WordChar
FalseToken <- "false" !WordChar

Null <- NullToken {
  return &Null{
    Loc: c.Loc(),
  }, nil
}
NullToken <- "null" !WordChar

SelfKeyword <- SelfToken {
  return &SelfKeyword{
    Loc: c.Loc(),
  }, nil
}
SelfToken <- "self" !WordChar

CommentToken <- '#' [^\n]* {
  comments, _ := c.globalStore["comments"].(map[int]string)
  if comments == nil {
    comments = make(map[int]string)
    c.globalStore["comments"] = comments
  }
  comments[c.pos.line] = string(c.text)
  return nil, nil
}

// Additional language constructs

TryCatch <- TryToken _ body:Block _ CatchToken _ '{' _ cs:(clause:CatchClause Sep { return clause, nil })* last:CatchClause? _ '}' {
  return &TryCatch{
    TryBody: body.(*Block),
    Clauses: sliceOfAppend[*CaseClause](cs, last),
    Loc: c.Loc(),
  }, nil
}

CatchClause <- binding:Symbol _ ColonToken _ typeName:Symbol _ ArrowToken _ expr:Form {
  // binding: TypeName => ... (typed pattern, same as case)
  return &CaseClause{
    Value: nil,
    Expr: expr.(Node),
    Binding: binding.(*Symbol).Name,
    TypePattern: typeName.(*Symbol),
    Loc: c.Loc(),
  }, nil
} / binding:Symbol _ ArrowToken _ expr:Form {
  // name => ... (catch-all, binds the error)
  return &CaseClause{
    Value: nil,
    Expr: expr.(Node),
    IsElse: true,
    Binding: binding.(*Symbol).Name,
    Loc: c.Loc(),
  }, nil
}

TryToken <- "try" !WordChar
CatchToken <- "catch" !WordChar

Raise <- RaiseToken _ value:Form {
  return &Raise{
    Value: value.(Node),
    Loc: c.Loc(),
  }, nil
}

RaiseToken <- "raise" !WordChar

Conditional <- IfToken _ '(' _ cond:Form _ ')' _ block:Block else_:ElseClause? {
  return &Conditional{
    Condition: cond.(Node),
    Then: block.(*Block),
    Else: else_,
    Loc: c.Loc(),
  }, nil
}

ElseClause <- _ ElseToken _ elseif:Conditional {
  // else if - wrap the conditional in a block
  return &Block{
    Forms: []Node{elseif.(Node)},
    Loc: elseif.(Node).GetSourceLocation(),
  }, nil
} / _ ElseToken _ block:Block {
  return block.(*Block), nil
}

IfToken <- "if" !WordChar
ElseToken <- "else" !WordChar
OrToken <- "or" !WordChar
AndToken <- "and" !WordChar

ForLoop <- ForTwoVarLoop / ForSingleVarLoop / ForConditionLoop / ForInfiniteLoop

ForSingleVarLoop <- ForToken _ '(' _ variable:Id typeAnnotation:(_ ColonToken _ t:Type)? _ InToken _ iterable:Form _ ')' _ body:Block {
  var varType TypeNode
  if typeAnnotation != nil {
    varType = typeAnnotation.([]interface{})[2].(TypeNode)
  }
  return &ForLoop{
    Variable: variable.(string),
    Type: varType,
    Iterable: iterable.(Node),
    LoopBody: body.(*Block),
    Loc: c.Loc(),
  }, nil
}

ForTwoVarLoop <- ForToken _ '(' _ key:Id _ CommaToken _ value:Id _ InToken _ iterable:Form _ ')' _ body:Block {
  return &ForLoop{
    KeyVariable: key.(string),
    ValueVariable: value.(string),
    Iterable: iterable.(Node),
    LoopBody: body.(*Block),
    Loc: c.Loc(),
  }, nil
}

ForConditionLoop <- ForToken _ '(' _ cond:Form _ ')' _ body:Block {
  return &ForLoop{
    Condition: cond.(Node),
    LoopBody: body.(*Block),
    Loc: c.Loc(),
  }, nil
}

ForInfiniteLoop <- ForToken _ body:Block {
  return &ForLoop{
    LoopBody: body.(*Block),
    Loc: c.Loc(),
  }, nil
}

ForToken <- "for" !WordChar
InToken <- "in" !WordChar

ArrowToken <- "=>"

BlockArg <- '{' _ paramsAndArrow:(params:BlockParams _ ArrowToken { return params, nil })? _ node:Expr rest:(Sep e:Expr { return e, nil })* _ '}' {
  var args []*SlotDecl
  if paramsAndArrow != nil {
    args = paramsAndArrow.([]*SlotDecl)
  }
  return &BlockArg{
    Args: args,
    BodyNode: &Block{
      Forms: sliceOfPrepend[Node](node, rest),
      Loc: c.Loc(),
    },
    Loc: c.Loc(),
  }, nil
}

BlockParams <- params:(p:BlockParam Sep { return p, nil })* last:BlockParam {
  return sliceOfAppend[*SlotDecl](params, last), nil
}

BlockParam <- name:Symbol {
  return &SlotDecl{
    Name: name.(*Symbol),
    Loc: c.Loc(),
  }, nil
}



Case <- CaseToken _ operand:('(' _ expr:Form _ ')' { return expr, nil })? _ '{' _ cs:(clause:CaseClause Sep { return clause, nil })* last:CaseClause? _ '}' {
  var expr Node
  if operand != nil {
    expr = operand.(Node)
  } else {
    // Desugar to case (true) when operand is omitted
    expr = &Boolean{
      Value: true,
      Loc: c.Loc(),
    }
  }
  return &Case{
    Expr: expr,
    NoOperand: operand == nil,
    Clauses: sliceOfAppend[*CaseClause](cs, last),
    Loc: c.Loc(),
  }, nil
}

CaseClause <- ElseToken _ ArrowToken _ expr:Form {
  // else => ... creates a clause that always matches
  return &CaseClause{
    Value: nil, // Value is not used for else clauses
    Expr: expr.(Node),
    IsElse: true,
    Loc: c.Loc(),
  }, nil
} / binding:Symbol _ ColonToken _ typeName:Symbol _ ArrowToken _ expr:Form {
  // binding: TypeName => ... creates a type pattern clause
  return &CaseClause{
    Value: nil,
    Expr: expr.(Node),
    Binding: binding.(*Symbol).Name,
    TypePattern: typeName.(*Symbol),
    Loc: c.Loc(),
  }, nil
} / value:Form _ ArrowToken _ expr:Form {
  return &CaseClause{
    Value: value.(Node),
    Expr: expr.(Node),
    IsElse: false,
    Loc: c.Loc(),
  }, nil
}

CaseToken <- "case" !WordChar

Assert <- AssertToken message:MessageArgs? _ block:Block {
  var msg Node
  if message != nil {
    msg = message.(Node)
  }
  return &Assert{
    Message: msg,
    Block: block.(*Block),
    Loc: c.Loc(),
  }, nil
}

MessageArgs <- '(' _ msg:Form _ ')' {
  return msg, nil
}

AssertToken <- "assert" !WordChar

Break <- BreakToken {
  return &Break{
    Loc: c.Loc(),
  }, nil
}

BreakToken <- "break" !WordChar

Continue <- ContinueToken {
  return &Continue{
    Loc: c.Loc(),
  }, nil
}

ContinueToken <- "continue" !WordChar

Reassignment <- target:Term _ op:AssignOp _ value:Form {
  return &Reassignment{
    Target: target.(Node),
    Modifier: op.(string),
    Value: value.(Node),
    Loc: c.Loc(),
  }, nil
}

AssignOp <- PlusEqualToken { return "+", nil } / EqualToken { return "=", nil }
PlusEqualToken <- "+="
EqualToken <- '='

TypeHint <- expr:Term _ DoubleColonToken _ type_:Type {
  return &TypeHint{
    Expr: expr.(Node),
    Type: type_.(TypeNode),
    Loc: c.Loc(),
  }, nil
}

DoubleColonToken <- "::"

DirectiveDecl <- DirectiveToken _ name:DirectiveName _ args:ArgTypes? _ OnToken _ locations:DirectiveLocations {
  var argTypes []*SlotDecl
  if args != nil {
    argTypes = args.([]*SlotDecl)
  }
  return &DirectiveDecl{
    Name: name.(string),
    Args: argTypes,
    Locations: locations.([]DirectiveLocation),
    Loc: c.Loc(),
  }, nil
}

DirectiveApplication <- _ '@' scope:(s:NamedType DotToken { return s, nil })? name:Id args:ArgValues? {
  var argValues []Keyed[Node]
  if args != nil {
    argValues = args.([]Keyed[Node])
  }
  var scopeNode *NamedTypeNode
  if scope != nil {
    scopeNode = scope.(*NamedTypeNode)
  }
  return &DirectiveApplication{
    Scope: scopeNode,
    Name: name.(string),
    Args: argValues,
    Loc: c.Loc(),
  }, nil
}

PrefixDirectiveApplication <- '@' name:Id args:ArgValues? {
  var argValues []Keyed[Node]
  if args != nil {
    argValues = args.([]Keyed[Node])
  }
  return &DirectiveApplication{
    Name:     name.(string),
    Args:     argValues,
    IsPrefix: true,
    Loc:      c.Loc(),
  }, nil
}

DirectiveLocations <- first:DirectiveLocation rest:(_ '|' _ loc:DirectiveLocation { return loc, nil })* {
  return sliceOfPrepend[DirectiveLocation](first, rest), nil
}

DirectiveLocation <- name:UpperId {
  return DirectiveLocation{Name: name.(string)}, nil
}

DirectiveName <- '@' name:Id {
  return name.(string), nil
}

DirectiveToken <- "directive" !WordChar
OnToken <- "on" !WordChar

Import <- ImportToken _ name:Symbol {
  return &ImportDecl{
    Name: name.(*Symbol),
    Loc:  c.Loc(),
  }, nil
}
ImportToken <- "import" !WordChar
