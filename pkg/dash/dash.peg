{
  package dash

  import "fmt"
}

Dash <- _ eles:(e:Expr Sep { return e, nil })* last:Expr? _ !. {
  return Block{
    Forms: sliceOfAppend[Node](eles, last),
    Loc: c.Loc(),
  }, nil
}

_ "whitespace" <- ([ \t\r\n] / CommentToken)*
_lineSpace <- [ \t]* CommentToken?

Sep <- (_ CommaToken / _lineSpace '\n') _
CommaToken <- ','

Expr <- Class / Slot / Reassignment / Form

Form <- Conditional / Let / Lambda / Match / Assert / DefaultExpr / Term

Term <- Literal / SelectOrCall / List / Object / Block / ParenForm / SymbolOrCall

ParenForm <- '(' _ expr:Form _ ')' {
  return expr.(Node), nil
}

// Handle Symbol followed by optional ()
SymbolOrCall <- Call / Symbol
Call <- name:Id args:ArgValues {
  // Symbol followed by () - create Select with nil Receiver
  argRecord := Record(args.([]Keyed[Node]))
  return Select{
    Receiver: nil,
    Field: name.(string),
    Args: &argRecord,
    Loc: c.Loc(),
  }, nil
}
Symbol <- name:Id {
  // Just a Symbol
  return Symbol{
    Name: name.(string),
    AutoCall: true,
    Loc: c.Loc(),
  }, nil
}

// Handle Select followed by optional ()
SelectOrCall <- left:Term _ DotToken _ name:Id args:ArgValues? {
  if args != nil {
    // Select followed by () - add Args field
    argRecord := Record(args.([]Keyed[Node]))
    return Select{
      Receiver: left.(Node),
      Field: name.(string),
      Args: &argRecord,
      Loc: c.Loc(),
    }, nil
  } else {
    // Just a Select
    return Select{
      Receiver: left.(Node),
      Field: name.(string),
      Args: nil,
      AutoCall: true,
      Loc: c.Loc(),
    }, nil
  }
}

Class <- ClsToken _ name:Id _ block:Block {
  return &ClassDecl{
    Named: name.(string),
    Value: block.(Block),
    Visibility: PublicVisibility, // TODO
    Loc: c.Loc(),
  }, nil
}
ClsToken <- "cls" !WordChar

Slot <- TypeAndArgsAndBlockSlot  // pub a(foo: Boolean!): Int! { 1 }
      / TypeAndBlockSlot         // pub a: Int! { 1 }  <- becomes a function that takes an empty record of args, can use other fields
      / TypeAndValueSlot         // pub a: Int! = 1    <- no longer required, default pre-initialized (don't need to worry about mutation)
      / ValueOnlySlot            // pub a = 1              <- as above, type inferred as Int!
      / TypeOnlySlot             // pub a: Int              <- as above, type inferred as Int!

TypeAndValueSlot <- vis:Visibility _ name:Id _ ColonToken _ type_:Type _ EqualToken _ value:Form {
  return SlotDecl{
    Named: name.(string),
    Type_: type_.(TypeNode),
    Value: value.(Node),
    Visibility: vis.(Visibility),
    Loc: c.Loc(),
  }, nil
}

ValueOnlySlot <- vis:Visibility _ name:Id _ EqualToken _ val:Form {
  return SlotDecl{
    Named: name.(string),
    Value: val.(Node),
    Visibility: vis.(Visibility),
    Loc: c.Loc(),
  }, nil
}

TypeOnlySlot <- vis:Visibility _ name:Id _ ColonToken _ type_:Type {
  return SlotDecl{
    Named: name.(string),
    Type_: type_.(TypeNode),
    Visibility: vis.(Visibility),
    Loc: c.Loc(),
  }, nil
}

TypeAndBlockSlot <- vis:Visibility _ name:Id _ ColonToken _ type_:Type _ block:Block {
  return SlotDecl{
    Named: name.(string),
    Type_: FunTypeNode{nil, type_.(TypeNode)},
    Value: &FunDecl{
      FunctionBase: FunctionBase{
        Args: nil,
        Body: block.(Block),
        Loc: c.Loc(),
      },
      Named: name.(string),
      Ret: type_.(TypeNode),
      Visibility: vis.(Visibility),
    },
    Visibility: vis.(Visibility),
    Loc: c.Loc(),
  }, nil
}

TypeAndArgsAndBlockSlot <- vis:Visibility _ name:Id _ args:ArgTypes _ ColonToken _ type_:Type _ block:Block {
  return SlotDecl{
    Named: name.(string),
    Type_: FunTypeNode{args.([]SlotDecl), type_.(TypeNode)},
    Value: &FunDecl{
      FunctionBase: FunctionBase{
        Args: args.([]SlotDecl),
        Body: block.(Block),
        Loc: c.Loc(),
      },
      Named: name.(string),
      Ret: type_.(TypeNode),
      Visibility: vis.(Visibility),
    },
    Visibility: vis.(Visibility),
    Loc: c.Loc(),
  }, nil
}

Visibility <- PubToken { return PublicVisibility, nil }
            / PvtToken { return PrivateVisibility, nil }
PubToken <- "pub" !WordChar
PvtToken <- "pvt" !WordChar

Id <- WordToken
WordToken <- !NullToken [a-zA-Z_][a-zA-Z0-9_]* {
  return string(c.text), nil
}
WordChar <- [a-zA-Z0-9_]
UpperId <- UpperToken
UpperToken <- [A-Z][a-zA-Z0-9]* {
  return string(c.text), nil
}

ArgValues <- '(' _ args:(a:Argument Sep { return a, nil })* last:Argument? _ ')' {
  return sliceOfAppend[Keyed[Node]](args, last), nil
}
ArgTypes <- '(' _ args:(a:ArgType Sep { return a, nil })* last:ArgType? _ ')' {
  return sliceOfAppend[SlotDecl](args, last), nil
}
ArgType <- slot:(ArgWithDefault / ArgWithBlockDefault / ArgWithType) {
  return slot.(SlotDecl), nil
}
ArgWithDefault <- name:Id _ ColonToken _ type_:Type _ EqualToken _ value:Form {
  return SlotDecl{
    Named: name.(string),
    Type_: type_.(TypeNode),
    Value: value.(Node),
    Loc: c.Loc(),
  }, nil
}
ArgWithBlockDefault <- name:Id _ ColonToken _ type_:Type _ block:Block {
  return SlotDecl{
    Named: name.(string),
    Type_: type_.(TypeNode),
    Value: block.(Block),
    Loc: c.Loc(),
  }, nil
}
ArgWithType <- name:Id _ ColonToken _ type_:Type {
  return SlotDecl{
    Named: name.(string),
    Type_: type_.(TypeNode),
    Loc: c.Loc(),
  }, nil
}

Argument <- KeyValue / PositionalValue

KeyValue <- key:WordToken ColonToken _ value:Form {
  return Keyed[Node]{Key: key.(string), Value: value.(Node), Positional: false}, nil
}

PositionalValue <- value:Form {
  return Keyed[Node]{Key: "", Value: value.(Node), Positional: true}, nil
}
ColonToken <- ':'

Type <- NonNull / NamedType / ListType / TypeVariable
NamedType <- name:UpperId {
  return NamedTypeNode{name.(string)}, nil
}
ListType <- '[' inner:Type ']' {
  return ListTypeNode{inner.(TypeNode)}, nil
}
NonNull <- inner:Type BangToken {
  return NonNullTypeNode{inner.(TypeNode)}, nil
}
TypeVariable <- v:[a-z] {
  return VariableTypeNode{v.([]byte)[0]}, nil
}

BangToken <- '!'

// Precedence levels from lowest to highest
DefaultExpr <- left:EqualityExpr _ InterroToken _ right:DefaultExpr {
  return Default{
    Left: left.(Node),
    Right: right.(Node),
    Loc: c.Loc(),
  }, nil
} / EqualityExpr

EqualityExpr <- left:EqualityExpr _ op:EqualityOp _ right:RelationalExpr {
  switch op.(string) {
  case "==":
    return Equality{
      Left: left.(Node),
      Right: right.(Node),
      Loc: c.Loc(),
    }, nil
  case "!=":
    return Inequality{
      Left: left.(Node),
      Right: right.(Node),
      Loc: c.Loc(),
    }, nil
  default:
    return nil, fmt.Errorf("unknown equality operator: %s", op.(string))
  }
} / RelationalExpr

EqualityOp <- "==" { return "==", nil } / "!=" { return "!=", nil }

RelationalExpr <- left:RelationalExpr _ op:RelationalOp _ right:AdditiveExpr {
  switch op.(string) {
  case "<":
    return LessThan{
      Left: left.(Node),
      Right: right.(Node),
      Loc: c.Loc(),
    }, nil
  case "<=":
    return LessThanEqual{
      Left: left.(Node),
      Right: right.(Node),
      Loc: c.Loc(),
    }, nil
  case ">":
    return GreaterThan{
      Left: left.(Node),
      Right: right.(Node),
      Loc: c.Loc(),
    }, nil
  case ">=":
    return GreaterThanEqual{
      Left: left.(Node),
      Right: right.(Node),
      Loc: c.Loc(),
    }, nil
  default:
    return nil, fmt.Errorf("unknown relational operator: %s", op.(string))
  }
} / AdditiveExpr

RelationalOp <- "<=" { return "<=", nil } / ">=" { return ">=", nil } / "<" { return "<", nil } / ">" { return ">", nil }

AdditiveExpr <- left:AdditiveExpr _ op:AdditiveOp _ right:MultiplicativeExpr {
  switch op.(string) {
  case "+":
    return Addition{
      Left: left.(Node),
      Right: right.(Node),
      Loc: c.Loc(),
    }, nil
  case "-":
    return Subtraction{
      Left: left.(Node),
      Right: right.(Node),
      Loc: c.Loc(),
    }, nil
  default:
    return nil, fmt.Errorf("unknown additive operator: %s", op.(string))
  }
} / MultiplicativeExpr

AdditiveOp <- "+" { return "+", nil } / "-" { return "-", nil }

MultiplicativeExpr <- left:MultiplicativeExpr _ op:MultiplicativeOp _ right:Term {
  switch op.(string) {
  case "*":
    return Multiplication{
      Left: left.(Node),
      Right: right.(Node),
      Loc: c.Loc(),
    }, nil
  case "/":
    return Division{
      Left: left.(Node),
      Right: right.(Node),
      Loc: c.Loc(),
    }, nil
  case "%":
    return Modulo{
      Left: left.(Node),
      Right: right.(Node),
      Loc: c.Loc(),
    }, nil
  default:
    return nil, fmt.Errorf("unknown multiplicative operator: %s", op.(string))
  }
} / Term

MultiplicativeOp <- "*" { return "*", nil } / "/" { return "/", nil } / "%" { return "%", nil }

InterroToken <- '?'
ReopenToken <- "<<"

DotToken <- '.'

List <- '[' _ eles:(e:Form Sep { return e, nil })* last:Form? _ ']' {
  return List{
    Elements: sliceOfAppend[Node](eles, last),
    Loc: c.Loc(),
  }, nil
}

Object <- "{{" _ vals:(v:KeyValue Sep { return v, nil })* last:KeyValue? _ "}}" {
  var slots []SlotDecl
  for _, kv := range sliceOfAppend[Keyed[Node]](vals, last) {
    slots = append(slots, SlotDecl{
      Named: kv.Key,
      Value: kv.Value,
      Loc: kv.Value.GetSourceLocation(),
    })
  }
  return &Object{
    Slots: slots,
    Loc: c.Loc(),
  }, nil
}

Block <- '{' _ eles:(e:Expr Sep { return e, nil })* last:Expr? _ '}' {
  return Block{
    Forms: sliceOfAppend[Node](eles, last),
    Loc: c.Loc(),
  }, nil
}

// Literals

Literal <- Int / Boolean / String / Quoted / Null

Int <- ('0' / NonZeroDecimalDigit DecimalDigit*) {
  value, err := strconv.ParseInt(string(c.text), 10, 64)
  if err != nil {
    return nil, err
  }
  return Int{
    Value: value,
    Loc: c.Loc(),
  }, nil
}

Exponent <- 'e'i [+-]? DecimalDigit+

String <- '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
  c.text = bytes.Replace(c.text, []byte(`\/`), []byte(`/`), -1)
  value, err := strconv.Unquote(string(c.text))
  if err != nil {
    return nil, err
  }
  return String{
    Value: value,
    Loc: c.Loc(),
  }, nil
}

EscapedChar <- [\x00-\x1f"\\]

EscapeSequence <- SingleCharEscape / UnicodeEscape

SingleCharEscape <- ["\\/bfnrt]

UnicodeEscape <- 'u' HexDigit HexDigit HexDigit HexDigit

DecimalDigit <- [0-9]

NonZeroDecimalDigit <- [1-9]

HexDigit <- [0-9a-f]i

Quoted <- '%' quoter:WordToken '{' raw:QuotedRawToken '}' {
  return Quoted{
    quoter.(string),
    raw.(string),
  }, nil
}
QuotedRawToken <- [^}]* {
  return string(c.text), nil
}

Boolean <- TrueToken {
  return Boolean{
    Value: true,
    Loc: c.Loc(),
  }, nil
} / FalseToken {
  return Boolean{
    Value: false,
    Loc: c.Loc(),
  }, nil
}
TrueToken <- "true" !WordChar
FalseToken <- "false" !WordChar

Null <- NullToken {
  return Null{
    Loc: c.Loc(),
  }, nil
}
NullToken <- "null" !WordChar

CommentToken <- '#' [^\n]*

// Additional language constructs

Conditional <- IfToken _ cond:Form _ block:Block else_:ElseClause? {
  return Conditional{
    Condition: cond.(Node),
    Then: block.(Block),
    Else: else_,
    Loc: c.Loc(),
  }, nil
}

ElseClause <- _ ElseToken _ block:Block {
  return block.(Block), nil
}

IfToken <- "if" !WordChar
ElseToken <- "else" !WordChar

Let <- LetToken _ name:Id _ EqualToken _ value:Form _ InToken _ expr:Form {
  return Let{
    Name: name.(string),
    Value: value.(Node),
    Expr: expr.(Node),
  }, nil
}

LetToken <- "let" !WordChar
InToken <- "in" !WordChar

Lambda <- LambdaToken args:LambdaArgs _ ArrowToken _ expr:Form {
  return &Lambda{
    FunctionBase: FunctionBase{
      Args: args.([]SlotDecl),
      Body: expr.(Node),
      Loc: c.Loc(),
    },
  }, nil
}
LambdaToken <- '\\'
ArrowToken <- "->"

LambdaArgs <- '(' _ args:(a:LambdaArg Sep { return a, nil })* last:LambdaArg? _ ')' {
  return sliceOfAppend[SlotDecl](args, last), nil
} / arg:LambdaArg {
  return []SlotDecl{arg.(SlotDecl)}, nil
}

LambdaArg <- ArgWithDefault / ArgWithBlockDefault / ArgWithType / ArgWithoutType

ArgWithoutType <- name:Id {
  return SlotDecl{
    Named: name.(string),
    Loc: c.Loc(),
  }, nil
}

Match <- MatchToken _ expr:Form _ WithToken _ '{' _ cs:(m:MatchCase Sep { return m, nil })* last:MatchCase? _ '}' {
  return Match{
    Expr: expr.(Node),
    Cases: sliceOfAppend[MatchCase](cs, last),
  }, nil
}

MatchCase <- pattern:Pattern _ "->" _ expr:Form {
  return MatchCase{
    Pattern: pattern.(Pattern),
    Expr: expr.(Node),
  }, nil
}

Pattern <- WildcardPattern / LiteralPattern / ConstructorPattern / VariablePattern

WildcardPattern <- '_' {
  return WildcardPattern{}, nil
}

LiteralPattern <- lit:Literal {
  return LiteralPattern{Value: lit.(Node)}, nil
}

ConstructorPattern <- name:UpperId args:PatternArgs? {
  var patterns []Pattern
  if args != nil {
    patterns = args.([]Pattern)
  }
  return ConstructorPattern{
    Name: name.(string),
    Args: patterns,
  }, nil
}

PatternArgs <- '(' _ patterns:(p:Pattern Sep { return p, nil })* last:Pattern? _ ')' {
  return sliceOfAppend[Pattern](patterns, last), nil
}

VariablePattern <- name:Id {
  return VariablePattern{Name: name.(string)}, nil
}

MatchToken <- "match" !WordChar
WithToken <- "with" !WordChar

Assert <- AssertToken message:MessageArgs? _ block:Block {
  var msg Node
  if message != nil {
    msg = message.(Node)
  }
  return Assert{
    Message: msg,
    Block: block.(Block),
    Loc: c.Loc(),
  }, nil
}

MessageArgs <- '(' _ msg:Form _ ')' {
  return msg, nil
}

AssertToken <- "assert" !WordChar

Reassignment <- target:Term _ op:AssignOp _ value:Form {
  return Reassignment{
    Target: target.(Node),
    Modifier: op.(string),
    Value: value.(Node),
    Loc: c.Loc(),
  }, nil
}

AssignOp <- PlusEqualToken { return "+", nil } / EqualToken { return "=", nil }
PlusEqualToken <- "+="
EqualToken <- '='

Reopen <- name:Id _ ReopenToken _ b:Block {
  return Reopen{
    Name: name.(string),
    Block: b.(Block),
    Loc: c.Loc(),
  }, nil
}
