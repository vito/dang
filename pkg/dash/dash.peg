{
  package dash
}

Dash <- es:(_ e:Expr _ CommaToken? { return e, nil })* !. {
  exprs := sliceOf[Node](es)
  log.Println("!!! DASH", exprs)
  return Block{
    Forms: exprs,
    Loc: &SourceLocation{
      Line: c.pos.line,
      Column: c.pos.col,
      Length: len(string(c.text)),
    },
  }, nil
}

Expr <- Class / Slot / Form

Form <- Conditional / Let / Lambda / Match / Infix / Term

Term <- Select / FunCall / List / Literal / Symbol

Class <- ClsToken _ name:Id _ block:Block {
  return ClassDecl{
    Named: name.(string),
    Value: block.(Block),
    Visibility: PrivateVisibility, // TODO
    Loc: &SourceLocation{
      Line: c.pos.line,
      Column: c.pos.col,
      Length: len(string(c.text)),
    },
  }, nil
}
ClsToken <- "cls"

Slot <- TypeAndArgsAndBlockSlot  // pub a(foo: Boolean!): Int! { 1 }
      / TypeAndBlockSlot         // pub a: Int! { 1 }  <- becomes a function that takes an empty record of args, can use other fields
      / TypeAndValueSlot         // pub a: Int! = 1    <- no longer required, default pre-initialized (don't need to worry about mutation)
      / ValueOnlySlot            // pub a = 1              <- as above, type inferred as Int!
      / TypeOnlySlot             // pub a: Int              <- as above, type inferred as Int!

TypeAndValueSlot <- vis:Visibility _ name:Id _ ColonToken _ type_:Type _ "=" _ value:Form {
  return SlotDecl{
    Named: name.(string),
    Type_: type_.(TypeNode),
    Value: value.(Node),
    Visibility: vis.(Visibility),
    Loc: &SourceLocation{
      Line: c.pos.line,
      Column: c.pos.col,
      Length: len(string(c.text)),
    },
  }, nil
}

ValueOnlySlot <- vis:Visibility _ name:Id _ '=' _ val:Form {
  return SlotDecl{
    Named: name.(string),
    Value: val.(Node),
    Visibility: vis.(Visibility),
    Loc: &SourceLocation{
      Line: c.pos.line,
      Column: c.pos.col,
      Length: len(string(c.text)),
    },
  }, nil
}

TypeOnlySlot <- vis:Visibility _ name:Id _ ColonToken _ type_:Type {
  return SlotDecl{
    Named: name.(string),
    Type_: type_.(TypeNode),
    Visibility: vis.(Visibility),
    Loc: &SourceLocation{
      Line: c.pos.line,
      Column: c.pos.col,
      Length: len(string(c.text)),
    },
  }, nil
}

TypeAndBlockSlot <- vis:Visibility _ name:Id _ ColonToken _ type_:Type _ block:Block {
  return SlotDecl{
    Named: name.(string),
    Type_: FunTypeNode{nil, type_.(TypeNode)},
    Value: FunDecl{
      Named: name.(string),
      Ret: type_.(TypeNode),
      Form: block.(Block),
      Loc: &SourceLocation{
        Line: c.pos.line,
        Column: c.pos.col,
        Length: len(string(c.text)),
      },
    },
    Visibility: vis.(Visibility),
    Loc: &SourceLocation{
      Line: c.pos.line,
      Column: c.pos.col,
      Length: len(string(c.text)),
    },
  }, nil
}

TypeAndArgsAndBlockSlot <- vis:Visibility _ name:Id _ args:ArgTypes _ ColonToken _ type_:Type _ block:Block {
  return SlotDecl{
    Named: name.(string),
    Type_: FunTypeNode{args.([]SlotDecl), type_.(TypeNode)},
    Value: FunDecl{
      Named: name.(string),
      Args: args.([]SlotDecl),
      Ret: type_.(TypeNode),
      Form: block.(Block),
      Loc: &SourceLocation{
        Line: c.pos.line,
        Column: c.pos.col,
        Length: len(string(c.text)),
      },
    },
    Visibility: vis.(Visibility),
    Loc: &SourceLocation{
      Line: c.pos.line,
      Column: c.pos.col,
      Length: len(string(c.text)),
    },
  }, nil
}

Visibility <- PubToken { return PublicVisibility, nil }
            / PvtToken { return PrivateVisibility, nil }
PubToken <- "pub"
PvtToken <- "pvt"

Id <- WordToken
WordToken <- [a-zA-Z_][a-zA-Z0-9_]* {
  return string(c.text), nil
}
UpperId <- UpperToken
UpperToken <- [A-Z][a-zA-Z0-9]* {
  return string(c.text), nil
}

FunCall <- name:Term args:ArgValues {
  return FunCall{
    Fun: name.(Node), 
    Args: Record(args.([]Keyed[Node])),
    Loc: &SourceLocation{
      Line: c.pos.line,
      Column: c.pos.col,
      Length: len(string(c.text)),
    },
  }, nil
}

ArgValues <- '(' args:KeyValue* ')' {
  return sliceOf[Keyed[Node]](args), nil
}
ArgTypes <- '(' args:ArgType* ')' {
  return sliceOf[SlotDecl](args), nil
}
ArgType <- slot:(ArgWithDefault / ArgWithBlockDefault / ArgWithType) CommaToken? {
  return slot.(SlotDecl), nil
}
ArgWithDefault <- name:Id _ ColonToken _ type_:Type _ "=" _ value:Form {
  return SlotDecl{
    Named: name.(string),
    Type_: type_.(TypeNode),
    Value: value.(Node),
  }, nil
}
ArgWithBlockDefault <- name:Id _ ColonToken _ type_:Type _ block:Block {
  return SlotDecl{
    Named: name.(string),
    Type_: type_.(TypeNode),
    Value: block.(Block),
  }, nil
}
ArgWithType <- name:Id _ ColonToken _ type_:Type {
  return SlotDecl{
    Named: name.(string),
    Type_: type_.(TypeNode),
  }, nil
}

KeyValue <- key:WordToken ColonToken _ value:Form CommaToken? {
  return Keyed[Node]{key.(string), value.(Node)}, nil
}
ColonToken <- ':'

Type <- NonNull / NamedType / ListType / TypeVariable
NamedType <- name:UpperId {
  return NamedTypeNode{name.(string)}, nil
}
ListType <- '[' inner:Type ']' {
  return ListTypeNode{inner.(TypeNode)}, nil
}
NonNull <- inner:Type BangToken {
  return NonNullTypeNode{inner.(TypeNode)}, nil
}
TypeVariable <- v:[a-z] {
  return VariableTypeNode{v.(byte)}, nil
}

BangToken <- '!'

CommaToken <- _ ',' _

Infix <- Default
Default <- left:Form _ InterroToken _ right:Term {
  return Default{
    Left: left.(Node), 
    Right: right.(Node),
    Loc: &SourceLocation{
      Line: c.pos.line,
      Column: c.pos.col,
      Length: len(string(c.text)),
    },
  }, nil
}
InterroToken <- '?'

Select <- left:Term _ DotToken _ name:Id {
  return Select{
    Receiver: left.(Node), 
    Field: name.(string),
    Loc: &SourceLocation{
      Line: c.pos.line,
      Column: c.pos.col,
      Length: len(string(c.text)),
    },
  }, nil
}
DotToken <- '.'

List <- '[' _ eles:(_ e:Form CommaToken? _ { return e, nil })* ']' {
  return List{
    Elements: sliceOf[Node](eles),
    Loc: &SourceLocation{
      Line: c.pos.line,
      Column: c.pos.col,
      Length: len(string(c.text)),
    },
  }, nil
}

Block <- '{' es:(_ e:Expr CommaToken? _ { return e, nil })* '}' {
  exprs := sliceOf[Node](es)
  log.Println("!!! BLOCK", exprs)
  return Block{
    Forms: exprs,
    Loc: &SourceLocation{
      Line: c.pos.line,
      Column: c.pos.col,
      Length: len(string(c.text)),
    },
  }, nil
}

Symbol <- name:Id {
  return Symbol{
    Name: name.(string),
    Loc: &SourceLocation{
      Line: c.pos.line,
      Column: c.pos.col,
      Length: len(string(c.text)),
    },
  }, nil
}

// Literals

Literal <- Int / Boolean / String / Quoted / Null

Int <- '0' / NonZeroDecimalDigit DecimalDigit* {
  value, err := strconv.ParseInt(string(c.text), 10, 64)
  if err != nil {
    return nil, err
  }
  return Int{
    Value: value,
    Loc: &SourceLocation{
      Line: c.pos.line,
      Column: c.pos.col,
      Length: len(string(c.text)),
    },
  }, nil
}

Exponent <- 'e'i [+-]? DecimalDigit+

String <- '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
  c.text = bytes.Replace(c.text, []byte(`\/`), []byte(`/`), -1)
  value, err := strconv.Unquote(string(c.text))
  if err != nil {
    return nil, err
  }
  return String{
    Value: value,
    Loc: &SourceLocation{
      Line: c.pos.line,
      Column: c.pos.col,
      Length: len(string(c.text)),
    },
  }, nil
}

EscapedChar <- [\x00-\x1f"\\]

EscapeSequence <- SingleCharEscape / UnicodeEscape

SingleCharEscape <- ["\\/bfnrt]

UnicodeEscape <- 'u' HexDigit HexDigit HexDigit HexDigit

DecimalDigit <- [0-9]

NonZeroDecimalDigit <- [1-9]

HexDigit <- [0-9a-f]i

Quoted <- '%' quoter:WordToken '{' raw:QuotedRawToken '}' {
  return Quoted{
    quoter.(string),
    raw.(string),
  }, nil
}
QuotedRawToken <- [^}]* {
  return string(c.text), nil
}

Boolean <- TrueToken { 
  return Boolean{
    Value: true,
    Loc: &SourceLocation{
      Line: c.pos.line,
      Column: c.pos.col,
      Length: len(string(c.text)),
    },
  }, nil 
} / FalseToken { 
  return Boolean{
    Value: false,
    Loc: &SourceLocation{
      Line: c.pos.line,
      Column: c.pos.col,
      Length: len(string(c.text)),
    },
  }, nil 
}
TrueToken <- "true"
FalseToken <- "false"

Null <- NullToken { 
  return Null{
    Loc: &SourceLocation{
      Line: c.pos.line,
      Column: c.pos.col,
      Length: len(string(c.text)),
    },
  }, nil 
}
NullToken <- "null"

_ "whitespace" <- ([ \t\r\n] / CommentToken)*

CommentToken <- '#' [^\n]*

// Additional language constructs

Conditional <- IfToken _ cond:Form _ block:Block else_:ElseClause? {
  return Conditional{
    Condition: cond.(Node),
    Then: block.(Block),
    Else: else_,
  }, nil
}

ElseClause <- _ ElseToken _ block:Block {
  return block.(Block), nil
}

IfToken <- "if"
ElseToken <- "else"

Let <- LetToken _ name:Id _ "=" _ value:Form _ InToken _ expr:Form {
  return Let{
    Name: name.(string),
    Value: value.(Node),
    Expr: expr.(Node),
  }, nil
}

LetToken <- "let"
InToken <- "in"

Lambda <- '\\' args:LambdaArgs _ "->" _ expr:Form {
  return Lambda{
    Args: args.([]string),
    Expr: expr.(Node),
  }, nil
}

LambdaArgs <- '(' args:LambdaArg* ')' {
  return sliceOf[string](args), nil
} / arg:Id {
  return []string{arg.(string)}, nil
}

LambdaArg <- arg:Id CommaToken? {
  return arg.(string), nil
}

Match <- MatchToken _ expr:Form _ WithToken _ '{' cases:MatchCase* '}' {
  return Match{
    Expr: expr.(Node),
    Cases: sliceOf[MatchCase](cases),
  }, nil
}

MatchCase <- pattern:Pattern _ "->" _ expr:Form CommaToken? {
  return MatchCase{
    Pattern: pattern.(Pattern),
    Expr: expr.(Node),
  }, nil
}

Pattern <- WildcardPattern / LiteralPattern / ConstructorPattern / VariablePattern

WildcardPattern <- '_' {
  return WildcardPattern{}, nil
}

LiteralPattern <- lit:Literal {
  return LiteralPattern{Value: lit.(Node)}, nil
}

ConstructorPattern <- name:UpperId args:PatternArgs? {
  var patterns []Pattern
  if args != nil {
    patterns = args.([]Pattern)
  }
  return ConstructorPattern{
    Name: name.(string),
    Args: patterns,
  }, nil
}

PatternArgs <- '(' patterns:PatternArg* ')' {
  return sliceOf[Pattern](patterns), nil
}

PatternArg <- pattern:Pattern CommaToken? {
  return pattern.(Pattern), nil
}

VariablePattern <- name:Id {
  return VariablePattern{Name: name.(string)}, nil
}

MatchToken <- "match"
WithToken <- "with"
