<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>pitui render debug</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
<style>
  :root {
    --bg: #0d1117;
    --surface: #161b22;
    --border: #30363d;
    --text: #e6edf3;
    --dim: #8b949e;
    --accent: #58a6ff;
    --green: #3fb950;
    --orange: #d29922;
    --red: #f85149;
    --purple: #bc8cff;
    --cyan: #56d4dd;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
    background: var(--bg);
    color: var(--text);
    padding: 16px;
  }
  h1 { font-size: 18px; font-weight: 600; margin-bottom: 4px; }
  .subtitle { color: var(--dim); font-size: 13px; margin-bottom: 16px; }
  .status { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 6px; }
  .status.connected { background: var(--green); }
  .status.disconnected { background: var(--red); }

  .grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(460px, 1fr));
    gap: 12px;
    margin-bottom: 12px;
  }
  .card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 12px;
  }
  .card h2 { font-size: 13px; font-weight: 500; color: var(--dim); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; }
  .card canvas { width: 100% !important; height: 180px !important; }

  .stats-bar {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    margin-bottom: 12px;
  }
  .stat {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 10px 16px;
    min-width: 110px;
  }
  .stat .label { font-size: 11px; color: var(--dim); text-transform: uppercase; letter-spacing: 0.5px; }
  .stat .value { font-size: 22px; font-weight: 600; font-variant-numeric: tabular-nums; }
  .stat .unit { font-size: 12px; color: var(--dim); }

  .controls {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 12px;
  }
  .controls label { font-size: 13px; color: var(--dim); }
  .controls select, .controls input {
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text);
    border-radius: 4px;
    padding: 4px 8px;
    font-size: 13px;
  }
  .controls button {
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text);
    border-radius: 4px;
    padding: 4px 12px;
    font-size: 13px;
    cursor: pointer;
  }
  .controls button:hover { border-color: var(--accent); }

  .comp-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 13px;
    font-variant-numeric: tabular-nums;
  }
  .comp-table th {
    text-align: left;
    color: var(--dim);
    font-weight: 500;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    padding: 6px 12px;
    border-bottom: 1px solid var(--border);
  }
  .comp-table td {
    padding: 5px 12px;
    border-bottom: 1px solid var(--border);
  }
  .comp-table tr:hover { background: rgba(88,166,255,0.05); }
  .comp-name { font-family: "SF Mono", "Fira Code", monospace; font-size: 12px; }
  .rate-high { color: var(--red); font-weight: 600; }
  .rate-low { color: var(--green); }
  .rate-mid { color: var(--orange); }
  .bar-bg { background: var(--border); border-radius: 3px; height: 6px; width: 80px; display: inline-block; vertical-align: middle; }
  .bar-fill { height: 100%; border-radius: 3px; }
</style>
</head>
<body>

<h1><span class="status disconnected" id="statusDot"></span>pitui render debug</h1>
<p class="subtitle" id="subtitle">Connecting...</p>

<div class="stats-bar">
  <div class="stat"><div class="label">Total Frames</div><div class="value" id="totalFrames">0</div></div>
  <div class="stat"><div class="label">Avg Total</div><div class="value" id="avgTotal">-</div><span class="unit">µs</span></div>
  <div class="stat"><div class="label">P99 Total</div><div class="value" id="p99Total">-</div><span class="unit">µs</span></div>
  <div class="stat"><div class="label">Full Redraws</div><div class="value" id="fullRedraws">0</div><div class="unit" id="lastRedrawWhy"></div></div>
  <div class="stat"><div class="label">Line Cache Rate</div><div class="value" id="cacheRate">-</div><span class="unit">%</span></div>
  <div class="stat"><div class="label">Compo Cache Rate</div><div class="value" id="compoCacheRate">-</div><span class="unit">%</span></div>
  <div class="stat"><div class="label">Avg Lines</div><div class="value" id="avgLines">-</div></div>
  <div class="stat"><div class="label">Avg Bytes/Frame</div><div class="value" id="avgBytes">-</div><span class="unit">B</span></div>
  <div class="stat"><div class="label">No-op Frames</div><div class="value" id="noopFrames">0</div></div>
  <div class="stat"><div class="label">Heap Alloc</div><div class="value" id="heapAlloc">-</div><span class="unit">MB</span></div>
  <div class="stat"><div class="label">Heap Objects</div><div class="value" id="heapObjects">-</div></div>
  <div class="stat"><div class="label">Allocs/Frame</div><div class="value" id="allocsPerFrame">-</div></div>
  <div class="stat"><div class="label">Bytes/Frame</div><div class="value" id="allocBytesPerFrame">-</div><span class="unit">KB</span></div>
  <div class="stat"><div class="label">Goroutines</div><div class="value" id="goroutines">-</div></div>
  <div class="stat"><div class="label">GC Cycles</div><div class="value" id="numGC">-</div></div>
  <div class="stat"><div class="label">Last GC Pause</div><div class="value" id="gcPause">-</div><span class="unit">µs</span></div>
  <div class="stat"><div class="label">Sys Memory</div><div class="value" id="sysMemory">-</div><span class="unit">MB</span></div>
</div>

<div class="controls">
  <label>Window:</label>
  <select id="windowSize">
    <option value="200">200 frames</option>
    <option value="500" selected>500 frames</option>
    <option value="1000">1000 frames</option>
    <option value="5000">5000 frames</option>
  </select>
  <label><input type="checkbox" id="showFullRedraws" checked> Mark full redraws</label>
  <button id="clearBtn">Clear</button>
  <label><input type="checkbox" id="pauseBtn"> Pause</label>
</div>

<div class="grid">
  <div class="card">
    <h2>Frame Duration (µs) — red dots = full redraws</h2>
    <canvas id="timingChart"></canvas>
  </div>
  <div class="card">
    <h2>Duration Breakdown (µs)</h2>
    <canvas id="breakdownChart"></canvas>
  </div>
  <div class="card">
    <h2>Lines: Total / Repainted / Line-cached</h2>
    <canvas id="linesChart"></canvas>
  </div>
  <div class="card">
    <h2>Component Cache Rate (%)</h2>
    <canvas id="cacheChart"></canvas>
  </div>
  <div class="card">
    <h2>Bytes Written to Terminal</h2>
    <canvas id="bytesChart"></canvas>
  </div>
  <div class="card">
    <h2>Changed Line Range (first → last)</h2>
    <canvas id="rangeChart"></canvas>
  </div>
  <div class="card">
    <h2>Heap Allocation (MB)</h2>
    <canvas id="heapChart"></canvas>
  </div>
  <div class="card">
    <h2>Allocations per Frame (objects / KB)</h2>
    <canvas id="allocChart"></canvas>
  </div>
  <div class="card">
    <h2>Goroutines</h2>
    <canvas id="goroutineChart"></canvas>
  </div>
  <div class="card">
    <h2>GC Pause (µs) — dots = GC events</h2>
    <canvas id="gcChart"></canvas>
  </div>
</div>

<div class="card" style="margin-bottom: 12px;">
  <h2>Per-Component Stats (aggregated over window)</h2>
  <table class="comp-table">
    <thead>
      <tr>
        <th>Component</th>
        <th>Appearances</th>
        <th>Rendered</th>
        <th>Cached</th>
        <th>Render Rate</th>
        <th></th>
        <th>Avg Time (µs)</th>
        <th>Max Time (µs)</th>
        <th>Avg Lines</th>
        <th>Status</th>
      </tr>
    </thead>
    <tbody id="compTableBody">
      <tr><td colspan="10" style="color:var(--dim)">Waiting for data with component stats...</td></tr>
    </tbody>
  </table>
</div>

<script>
// ── Data store ──────────────────────────────────────────────────────────────
const allData = [];
let paused = false;

// ── Chart.js defaults ──────────────────────────────────────────────────────
Chart.defaults.color = '#8b949e';
Chart.defaults.borderColor = '#30363d';
Chart.defaults.font.size = 11;
Chart.defaults.animation = false;
Chart.defaults.elements.point.radius = 0;
Chart.defaults.elements.point.hoverRadius = 3;
Chart.defaults.elements.line.borderWidth = 1.5;

const commonScales = {
  x: { display: false },
  y: { beginAtZero: true, grid: { color: '#21262d' } }
};

function makeChart(id, datasets, opts = {}) {
  return new Chart(document.getElementById(id), {
    type: 'line',
    data: { labels: [], datasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: { mode: 'index', intersect: false },
      plugins: {
        legend: { display: datasets.length > 1, position: 'top', labels: { boxWidth: 10, padding: 8 } },
        tooltip: { enabled: true },
      },
      scales: { ...commonScales, ...opts.scales },
    },
  });
}

// ── Charts ─────────────────────────────────────────────────────────────────
const timingChart = makeChart('timingChart', [
  { label: 'Total', borderColor: '#58a6ff', backgroundColor: 'rgba(88,166,255,0.1)', fill: true, data: [] },
]);

const breakdownChart = makeChart('breakdownChart', [
  { label: 'Render', borderColor: '#3fb950', data: [] },
  { label: 'Composite', borderColor: '#56d4dd', data: [] },
  { label: 'Diff', borderColor: '#d29922', data: [] },
  { label: 'Write', borderColor: '#f85149', data: [] },
]);

const linesChart = makeChart('linesChart', [
  { label: 'Total', borderColor: '#58a6ff', data: [] },
  { label: 'Repainted', borderColor: '#f85149', backgroundColor: 'rgba(248,81,73,0.1)', fill: true, data: [] },
  { label: 'Line-cached', borderColor: '#3fb950', data: [] },
]);

const cacheChart = makeChart('cacheChart', [
  { label: 'Compo Cache %', borderColor: '#3fb950', backgroundColor: 'rgba(63,185,80,0.1)', fill: true, data: [] },
], {
  scales: { y: { beginAtZero: true, max: 100, grid: { color: '#21262d' } } }
});

const bytesChart = makeChart('bytesChart', [
  { label: 'Bytes', borderColor: '#bc8cff', backgroundColor: 'rgba(188,140,255,0.1)', fill: true, data: [] },
]);

const rangeChart = makeChart('rangeChart', [
  { label: 'First Changed', borderColor: '#d29922', data: [] },
  { label: 'Last Changed', borderColor: '#f85149', data: [] },
  { label: 'Total Lines', borderColor: '#58a6ff', borderDash: [4, 4], data: [] },
]);

const heapChart = makeChart('heapChart', [
  { label: 'Heap Alloc', borderColor: '#58a6ff', backgroundColor: 'rgba(88,166,255,0.1)', fill: true, data: [] },
  { label: 'Heap In-use', borderColor: '#bc8cff', data: [] },
  { label: 'Heap Idle', borderColor: '#8b949e', borderDash: [4, 4], data: [] },
  { label: 'Stack In-use', borderColor: '#d29922', data: [] },
]);

const allocChart = makeChart('allocChart', [
  { label: 'Mallocs (objects)', borderColor: '#f85149', backgroundColor: 'rgba(248,81,73,0.1)', fill: true, data: [], yAxisID: 'y' },
  { label: 'Alloc Δ (KB)', borderColor: '#3fb950', data: [], yAxisID: 'y1' },
], {
  scales: {
    y: { beginAtZero: true, position: 'left', grid: { color: '#21262d' } },
    y1: { beginAtZero: true, position: 'right', grid: { drawOnChartArea: false } },
  }
});

const goroutineChart = makeChart('goroutineChart', [
  { label: 'Goroutines', borderColor: '#56d4dd', backgroundColor: 'rgba(86,212,221,0.1)', fill: true, data: [] },
]);

const gcChart = makeChart('gcChart', [
  { label: 'GC Pause', borderColor: '#d29922', backgroundColor: 'rgba(210,153,34,0.1)', fill: true, data: [] },
]);

const charts = [timingChart, breakdownChart, linesChart, cacheChart, bytesChart, rangeChart, heapChart, allocChart, goroutineChart, gcChart];

// ── Component stats helpers ────────────────────────────────────────────────
// Count cached vs rendered components in a single frame's component list.
function frameCacheStats(frame) {
  if (!frame.components || frame.components.length === 0) return { total: 0, cached: 0 };
  let total = 0, cached = 0;
  for (const c of frame.components) {
    total++;
    if (c.cached) cached++;
  }
  return { total, cached };
}

// ── Update logic ───────────────────────────────────────────────────────────
function getWindow() {
  return parseInt(document.getElementById('windowSize').value);
}

function updateStats() {
  const n = allData.length;
  document.getElementById('totalFrames').textContent = n;
  if (n === 0) return;

  const totals = allData.map(d => d.total_us);
  const avg = (totals.reduce((a, b) => a + b, 0) / n) | 0;
  document.getElementById('avgTotal').textContent = avg;

  const sorted = [...totals].sort((a, b) => a - b);
  const p99 = sorted[Math.floor(n * 0.99)] || sorted[n - 1];
  document.getElementById('p99Total').textContent = p99;

  const fullRedraws = allData.filter(d => d.full_redraw);
  document.getElementById('fullRedraws').textContent = fullRedraws.length;
  if (fullRedraws.length > 0) {
    const last = fullRedraws[fullRedraws.length - 1];
    document.getElementById('lastRedrawWhy').textContent = last.full_redraw_why || '';
  }

  // Line-level cache rate (unchanged lines in diff).
  let totalLines = 0, totalLineCached = 0;
  for (const d of allData) {
    totalLines += d.total_lines;
    totalLineCached += d.cache_hits;
  }
  const lineRate = totalLines > 0 ? ((totalLineCached / totalLines) * 100).toFixed(1) : '-';
  document.getElementById('cacheRate').textContent = lineRate;

  // Component-level cache rate (Compo cache hits).
  let totalComps = 0, totalCompCached = 0;
  for (const d of allData) {
    const s = frameCacheStats(d);
    totalComps += s.total;
    totalCompCached += s.cached;
  }
  const compoRate = totalComps > 0 ? ((totalCompCached / totalComps) * 100).toFixed(1) : '-';
  document.getElementById('compoCacheRate').textContent = compoRate;

  const avgL = (allData.reduce((a, d) => a + d.total_lines, 0) / n).toFixed(0);
  document.getElementById('avgLines').textContent = avgL;

  const avgB = (allData.reduce((a, d) => a + d.bytes_written, 0) / n).toFixed(0);
  document.getElementById('avgBytes').textContent = avgB;

  // No-op frames: no lines changed AND no bytes written.
  const noop = allData.filter(d => d.first_changed === -1).length;
  document.getElementById('noopFrames').textContent = noop;

  // Runtime metrics (from latest frame).
  const latest = allData[n - 1];
  if (latest.heap_alloc !== undefined) {
    document.getElementById('heapAlloc').textContent = (latest.heap_alloc / (1024 * 1024)).toFixed(1);
    document.getElementById('heapObjects').textContent = formatNum(latest.heap_objects);
    document.getElementById('goroutines').textContent = latest.goroutines;
    document.getElementById('numGC').textContent = latest.num_gc;
    document.getElementById('gcPause').textContent = ((latest.gc_pause_ns || 0) / 1000).toFixed(0);
    document.getElementById('sysMemory').textContent = (latest.sys / (1024 * 1024)).toFixed(1);
  }

  // Per-frame allocation averages.
  const framesWithAlloc = allData.filter(d => d.mallocs !== undefined);
  if (framesWithAlloc.length > 0) {
    const avgMallocs = (framesWithAlloc.reduce((a, d) => a + d.mallocs, 0) / framesWithAlloc.length).toFixed(0);
    const avgAllocBytes = (framesWithAlloc.reduce((a, d) => a + d.heap_alloc_delta, 0) / framesWithAlloc.length / 1024).toFixed(1);
    document.getElementById('allocsPerFrame').textContent = avgMallocs;
    document.getElementById('allocBytesPerFrame').textContent = avgAllocBytes;
  }

  updateComponentTable();
}

function formatNum(n) {
  if (n >= 1e6) return (n / 1e6).toFixed(1) + 'M';
  if (n >= 1e3) return (n / 1e3).toFixed(1) + 'K';
  return '' + n;
}

function shortName(name) {
  // "github.com/vito/dang/cmd/render-stress.stressLog" → "stressLog"
  const parts = name.split('.');
  return parts[parts.length - 1] || name;
}

function updateComponentTable() {
  const win = getWindow();
  const slice = allData.slice(-win);

  // Aggregate per component name.
  const agg = {};
  for (const frame of slice) {
    if (!frame.components) continue;
    for (const c of frame.components) {
      if (!agg[c.name]) {
        agg[c.name] = { appearances: 0, rendered: 0, cached: 0, totalUs: 0, maxUs: 0, totalLines: 0 };
      }
      const a = agg[c.name];
      a.appearances++;
      if (c.cached) {
        a.cached++;
      } else {
        a.rendered++;
        a.totalUs += c.render_us;
        if (c.render_us > a.maxUs) a.maxUs = c.render_us;
      }
      a.totalLines += c.lines;
    }
  }

  const tbody = document.getElementById('compTableBody');
  const names = Object.keys(agg).sort((a, b) => agg[b].totalUs - agg[a].totalUs);

  if (names.length === 0) {
    tbody.innerHTML = '<tr><td colspan="10" style="color:var(--dim)">No component data yet</td></tr>';
    return;
  }

  let html = '';
  for (const name of names) {
    const a = agg[name];
    const renderRate = a.appearances > 0 ? (a.rendered / a.appearances * 100) : 0;
    const avgUs = a.rendered > 0 ? (a.totalUs / a.rendered) | 0 : 0;
    const avgLines = a.appearances > 0 ? (a.totalLines / a.appearances).toFixed(1) : '0';

    let rateClass, statusText;
    if (renderRate >= 90) {
      rateClass = 'rate-high';
      statusText = '⟳ always renders';
    } else if (renderRate === 0) {
      rateClass = 'rate-low';
      statusText = '✓ fully cached';
    } else if (renderRate <= 10) {
      rateClass = 'rate-low';
      statusText = '✓ mostly cached';
    } else {
      rateClass = 'rate-mid';
      statusText = '△ partial cache';
    }

    const barColor = renderRate >= 90 ? 'var(--red)' : renderRate === 0 ? 'var(--green)' : 'var(--orange)';

    html += '<tr>'
      + '<td class="comp-name" title="' + name + '">' + shortName(name) + '</td>'
      + '<td>' + a.appearances + '</td>'
      + '<td>' + a.rendered + '</td>'
      + '<td>' + a.cached + '</td>'
      + '<td class="' + rateClass + '">' + renderRate.toFixed(0) + '%</td>'
      + '<td><span class="bar-bg"><span class="bar-fill" style="width:' + renderRate + '%;background:' + barColor + '"></span></span></td>'
      + '<td>' + avgUs + '</td>'
      + '<td>' + a.maxUs + '</td>'
      + '<td>' + avgLines + '</td>'
      + '<td class="' + rateClass + '">' + statusText + '</td>'
      + '</tr>';
  }
  tbody.innerHTML = html;
}

function updateCharts() {
  const win = getWindow();
  const slice = allData.slice(-win);
  const labels = slice.map((_, i) => i);
  const showFull = document.getElementById('showFullRedraws').checked;

  // Timing chart
  timingChart.data.labels = labels;
  timingChart.data.datasets[0].data = slice.map(d => d.total_us);
  if (showFull) {
    timingChart.data.datasets[0].pointRadius = slice.map(d => d.full_redraw ? 3 : 0);
    timingChart.data.datasets[0].pointBackgroundColor = slice.map(d => d.full_redraw ? '#f85149' : 'transparent');
  } else {
    timingChart.data.datasets[0].pointRadius = 0;
  }

  // Breakdown chart
  breakdownChart.data.labels = labels;
  breakdownChart.data.datasets[0].data = slice.map(d => d.render_us);
  breakdownChart.data.datasets[1].data = slice.map(d => d.composite_us);
  breakdownChart.data.datasets[2].data = slice.map(d => d.diff_us);
  breakdownChart.data.datasets[3].data = slice.map(d => d.write_us);

  // Lines chart
  linesChart.data.labels = labels;
  linesChart.data.datasets[0].data = slice.map(d => d.total_lines);
  linesChart.data.datasets[1].data = slice.map(d => d.lines_repainted);
  linesChart.data.datasets[2].data = slice.map(d => d.cache_hits);

  // Component cache chart
  cacheChart.data.labels = labels;
  cacheChart.data.datasets[0].data = slice.map(d => {
    const s = frameCacheStats(d);
    return s.total > 0 ? ((s.cached / s.total) * 100).toFixed(1) : 100;
  });

  // Bytes chart
  bytesChart.data.labels = labels;
  bytesChart.data.datasets[0].data = slice.map(d => d.bytes_written);

  // Changed line range chart
  rangeChart.data.labels = labels;
  rangeChart.data.datasets[0].data = slice.map(d => d.first_changed >= 0 ? d.first_changed : null);
  rangeChart.data.datasets[1].data = slice.map(d => d.last_changed >= 0 ? d.last_changed : null);
  rangeChart.data.datasets[2].data = slice.map(d => d.total_lines);

  // Heap chart (MB)
  heapChart.data.labels = labels;
  heapChart.data.datasets[0].data = slice.map(d => d.heap_alloc ? (d.heap_alloc / (1024 * 1024)).toFixed(2) : null);
  heapChart.data.datasets[1].data = slice.map(d => d.heap_inuse ? (d.heap_inuse / (1024 * 1024)).toFixed(2) : null);
  heapChart.data.datasets[2].data = slice.map(d => d.heap_idle ? (d.heap_idle / (1024 * 1024)).toFixed(2) : null);
  heapChart.data.datasets[3].data = slice.map(d => d.stack_inuse ? (d.stack_inuse / (1024 * 1024)).toFixed(2) : null);

  // Allocations per frame chart
  allocChart.data.labels = labels;
  allocChart.data.datasets[0].data = slice.map(d => d.mallocs || 0);
  allocChart.data.datasets[1].data = slice.map(d => d.heap_alloc_delta ? (d.heap_alloc_delta / 1024).toFixed(1) : 0);

  // Goroutines chart
  goroutineChart.data.labels = labels;
  goroutineChart.data.datasets[0].data = slice.map(d => d.goroutines || 0);

  // GC pause chart (ns → µs)
  gcChart.data.labels = labels;
  gcChart.data.datasets[0].data = slice.map(d => d.gc_pause_ns ? (d.gc_pause_ns / 1000).toFixed(1) : 0);
  // Show dots on frames where a GC actually happened (num_gc changed from previous frame).
  gcChart.data.datasets[0].pointRadius = slice.map((d, i) => {
    if (i === 0) return 0;
    return (d.num_gc !== slice[i - 1].num_gc) ? 4 : 0;
  });
  gcChart.data.datasets[0].pointBackgroundColor = slice.map((d, i) => {
    if (i === 0) return 'transparent';
    return (d.num_gc !== slice[i - 1].num_gc) ? '#d29922' : 'transparent';
  });

  for (const c of charts) c.update();
}

// Batch updates to avoid hammering the DOM.
let updatePending = false;
function scheduleUpdate() {
  if (updatePending) return;
  updatePending = true;
  requestAnimationFrame(() => {
    updatePending = false;
    if (!paused) {
      updateStats();
      updateCharts();
    }
  });
}

// ── SSE connection ─────────────────────────────────────────────────────────
function connect() {
  const dot = document.getElementById('statusDot');
  const sub = document.getElementById('subtitle');

  const es = new EventSource('/events');

  es.onopen = () => {
    dot.className = 'status connected';
    sub.textContent = 'Connected — streaming render stats';
  };

  es.onmessage = (e) => {
    try {
      const d = JSON.parse(e.data);
      allData.push(d);
      scheduleUpdate();
    } catch (err) {
      // skip malformed
    }
  };

  es.onerror = () => {
    dot.className = 'status disconnected';
    sub.textContent = 'Disconnected — retrying...';
    es.close();
    setTimeout(connect, 2000);
  };
}

// ── Controls ───────────────────────────────────────────────────────────────
document.getElementById('windowSize').addEventListener('change', () => {
  updateCharts();
});

document.getElementById('showFullRedraws').addEventListener('change', () => {
  updateCharts();
});

document.getElementById('clearBtn').addEventListener('click', () => {
  allData.length = 0;
  updateStats();
  updateCharts();
});

document.getElementById('pauseBtn').addEventListener('change', (e) => {
  paused = e.target.checked;
  if (!paused) {
    updateStats();
    updateCharts();
  }
});

// ── Go ─────────────────────────────────────────────────────────────────────
connect();
</script>
</body>
</html>
