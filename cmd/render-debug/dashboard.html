<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>pitui render debug</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
<style>
  :root {
    --bg: #0d1117;
    --surface: #161b22;
    --border: #30363d;
    --text: #e6edf3;
    --dim: #8b949e;
    --accent: #58a6ff;
    --green: #3fb950;
    --orange: #d29922;
    --red: #f85149;
    --purple: #bc8cff;
    --cyan: #56d4dd;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
    background: var(--bg);
    color: var(--text);
    padding: 16px;
  }
  h1 { font-size: 18px; font-weight: 600; margin-bottom: 4px; }
  .subtitle { color: var(--dim); font-size: 13px; margin-bottom: 16px; }
  .status { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 6px; }
  .status.connected { background: var(--green); }
  .status.disconnected { background: var(--red); }

  .grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(460px, 1fr));
    gap: 12px;
    margin-bottom: 12px;
  }
  .card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 12px;
  }
  .card h2 { font-size: 13px; font-weight: 500; color: var(--dim); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; }
  .card canvas { width: 100% !important; height: 180px !important; }

  .stats-bar {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    margin-bottom: 12px;
  }
  .stat {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 10px 16px;
    min-width: 110px;
  }
  .stat .label { font-size: 11px; color: var(--dim); text-transform: uppercase; letter-spacing: 0.5px; }
  .stat .value { font-size: 22px; font-weight: 600; font-variant-numeric: tabular-nums; }
  .stat .unit { font-size: 12px; color: var(--dim); }

  .controls {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 12px;
  }
  .controls label { font-size: 13px; color: var(--dim); }
  .controls select, .controls input {
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text);
    border-radius: 4px;
    padding: 4px 8px;
    font-size: 13px;
  }
  .controls button {
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text);
    border-radius: 4px;
    padding: 4px 12px;
    font-size: 13px;
    cursor: pointer;
  }
  .controls button:hover { border-color: var(--accent); }

  .comp-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 13px;
    font-variant-numeric: tabular-nums;
  }
  .comp-table th {
    text-align: left;
    color: var(--dim);
    font-weight: 500;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    padding: 6px 12px;
    border-bottom: 1px solid var(--border);
  }
  .comp-table td {
    padding: 5px 12px;
    border-bottom: 1px solid var(--border);
  }
  .comp-table tr:hover { background: rgba(88,166,255,0.05); }
  .comp-name { font-family: "SF Mono", "Fira Code", monospace; font-size: 12px; }
  .rate-high { color: var(--red); font-weight: 600; }
  .rate-low { color: var(--green); }
  .rate-mid { color: var(--orange); }
  .bar-bg { background: var(--border); border-radius: 3px; height: 6px; width: 80px; display: inline-block; vertical-align: middle; }
  .bar-fill { height: 100%; border-radius: 3px; }
</style>
</head>
<body>

<h1><span class="status disconnected" id="statusDot"></span>pitui render debug</h1>
<p class="subtitle" id="subtitle">Connecting...</p>

<div class="stats-bar">
  <div class="stat"><div class="label">Total Frames</div><div class="value" id="totalFrames">0</div></div>
  <div class="stat"><div class="label">Avg Total</div><div class="value" id="avgTotal">-</div><span class="unit">µs</span></div>
  <div class="stat"><div class="label">P99 Total</div><div class="value" id="p99Total">-</div><span class="unit">µs</span></div>
  <div class="stat"><div class="label">Full Redraws</div><div class="value" id="fullRedraws">0</div><div class="unit" id="lastRedrawWhy"></div></div>
  <div class="stat"><div class="label">Line Cache Rate</div><div class="value" id="cacheRate">-</div><span class="unit">%</span></div>
  <div class="stat"><div class="label">Compo Cache Rate</div><div class="value" id="compoCacheRate">-</div><span class="unit">%</span></div>
  <div class="stat"><div class="label">Avg Lines</div><div class="value" id="avgLines">-</div></div>
  <div class="stat"><div class="label">Avg Bytes/Frame</div><div class="value" id="avgBytes">-</div><span class="unit">B</span></div>
  <div class="stat"><div class="label">No-op Frames</div><div class="value" id="noopFrames">0</div></div>
  <div class="stat"><div class="label">Heap Alloc</div><div class="value" id="heapAlloc">-</div><span class="unit">MB</span></div>
  <div class="stat"><div class="label">Heap Objects</div><div class="value" id="heapObjects">-</div></div>
  <div class="stat"><div class="label">Allocs/Frame</div><div class="value" id="allocsPerFrame">-</div></div>
  <div class="stat"><div class="label">Bytes/Frame</div><div class="value" id="allocBytesPerFrame">-</div><span class="unit">KB</span></div>
  <div class="stat"><div class="label">Goroutines</div><div class="value" id="goroutines">-</div></div>
  <div class="stat"><div class="label">GC Cycles</div><div class="value" id="numGC">-</div></div>
  <div class="stat"><div class="label">Last GC Pause</div><div class="value" id="gcPause">-</div><span class="unit">µs</span></div>
  <div class="stat"><div class="label">Sys Memory</div><div class="value" id="sysMemory">-</div><span class="unit">MB</span></div>
</div>

<div class="controls">
  <label>Window:</label>
  <select id="windowSize">
    <option value="200">200 frames</option>
    <option value="500" selected>500 frames</option>
    <option value="1000">1000 frames</option>
    <option value="5000">5000 frames</option>
  </select>
  <label><input type="checkbox" id="showFullRedraws" checked> Mark full redraws</label>
  <label><input type="checkbox" id="overlayGens" checked> Overlay sessions</label>
  <button id="clearBtn">Clear</button>
  <label><input type="checkbox" id="pauseBtn"> Pause</label>
  <span id="genIndicator" style="font-size:12px;color:var(--dim)"></span>
</div>

<div class="grid">
  <div class="card">
    <h2>Frame Duration (µs) — red dots = full redraws</h2>
    <canvas id="timingChart"></canvas>
  </div>
  <div class="card">
    <h2>Duration Breakdown (µs)</h2>
    <canvas id="breakdownChart"></canvas>
  </div>
  <div class="card">
    <h2>Lines: Total / Repainted / Line-cached</h2>
    <canvas id="linesChart"></canvas>
  </div>
  <div class="card">
    <h2>Component Cache Rate (%)</h2>
    <canvas id="cacheChart"></canvas>
  </div>
  <div class="card">
    <h2>Bytes Written to Terminal</h2>
    <canvas id="bytesChart"></canvas>
  </div>
  <div class="card">
    <h2>Changed Line Range (first → last)</h2>
    <canvas id="rangeChart"></canvas>
  </div>
  <div class="card">
    <h2>Heap Allocation (MB)</h2>
    <canvas id="heapChart"></canvas>
  </div>
  <div class="card">
    <h2>Allocations per Frame (objects / KB)</h2>
    <canvas id="allocChart"></canvas>
  </div>
  <div class="card">
    <h2>Goroutines</h2>
    <canvas id="goroutineChart"></canvas>
  </div>
  <div class="card">
    <h2>GC Pause (µs) — dots = GC events</h2>
    <canvas id="gcChart"></canvas>
  </div>
</div>

<div class="card" style="margin-bottom: 12px;">
  <h2>Per-Component Stats (aggregated over window)</h2>
  <table class="comp-table">
    <thead>
      <tr>
        <th>Component</th>
        <th>Appearances</th>
        <th>Rendered</th>
        <th>Cached</th>
        <th>Render Rate</th>
        <th></th>
        <th>Avg Time (µs)</th>
        <th>Max Time (µs)</th>
        <th>Avg Lines</th>
        <th>Status</th>
      </tr>
    </thead>
    <tbody id="compTableBody">
      <tr><td colspan="10" style="color:var(--dim)">Waiting for data with component stats...</td></tr>
    </tbody>
  </table>
</div>

<script>
// ── Data store ──────────────────────────────────────────────────────────────
// Each generation is one program session (delimited by session_start events).
// Frames within a generation share the same X axis (frame index) so that
// different sessions can be overlaid for comparison.
const generations = [[]]; // generations[i] = array of frame objects
let paused = false;

// Convenience: current (latest) generation.
function curGen() { return generations[generations.length - 1]; }

// Start a new generation (called when a session_start event arrives).
function startNewGeneration() {
  if (curGen().length > 0) {
    generations.push([]);
  }
}

// ── Chart.js defaults ──────────────────────────────────────────────────────
Chart.defaults.color = '#8b949e';
Chart.defaults.borderColor = '#30363d';
Chart.defaults.font.size = 11;
Chart.defaults.animation = false;
Chart.defaults.elements.point.radius = 0;
Chart.defaults.elements.point.hoverRadius = 3;
Chart.defaults.elements.line.borderWidth = 1.5;

const commonScales = {
  x: { display: false },
  y: { beginAtZero: true, grid: { color: '#21262d' } }
};

function makeChart(id, datasets, opts = {}) {
  return new Chart(document.getElementById(id), {
    type: 'line',
    data: { labels: [], datasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: { mode: 'index', intersect: false },
      plugins: {
        legend: { display: datasets.length > 1, position: 'top', labels: { boxWidth: 10, padding: 8 } },
        tooltip: { enabled: true },
      },
      scales: { ...commonScales, ...opts.scales },
    },
  });
}

// ── Chart definitions ──────────────────────────────────────────────────────
// Each entry describes one chart: its Chart.js instance, and a list of
// "series" — each series maps a frame to a value.  When overlay mode is
// active we duplicate the series for each generation.

// A series descriptor: { label, color, fill?, bg?, yAxisID?, extract(frame) }
const chartDefs = [];

function defChart(id, series, opts) {
  const datasets = series.map(s => {
    const ds = { label: s.label, borderColor: s.color, data: [] };
    if (s.bg) { ds.backgroundColor = s.bg; ds.fill = true; }
    if (s.dash) ds.borderDash = s.dash;
    if (s.yAxisID) ds.yAxisID = s.yAxisID;
    return ds;
  });
  const chart = makeChart(id, datasets, opts);
  chartDefs.push({ chart, series, opts });
  return chart;
}

const timingChart = defChart('timingChart', [
  { label: 'Total', color: '#58a6ff', bg: 'rgba(88,166,255,0.1)', extract: d => d.total_us },
]);

const breakdownChart = defChart('breakdownChart', [
  { label: 'Render', color: '#3fb950', extract: d => d.render_us },
  { label: 'Composite', color: '#56d4dd', extract: d => d.composite_us },
  { label: 'Diff', color: '#d29922', extract: d => d.diff_us },
  { label: 'Write', color: '#f85149', extract: d => d.write_us },
]);

const linesChart = defChart('linesChart', [
  { label: 'Total', color: '#58a6ff', extract: d => d.total_lines },
  { label: 'Repainted', color: '#f85149', bg: 'rgba(248,81,73,0.1)', extract: d => d.lines_repainted },
  { label: 'Line-cached', color: '#3fb950', extract: d => d.cache_hits },
]);

const cacheChart = defChart('cacheChart', [
  { label: 'Compo Cache %', color: '#3fb950', bg: 'rgba(63,185,80,0.1)', extract: d => {
    const s = frameCacheStats(d);
    return s.total > 0 ? ((s.cached / s.total) * 100) : 100;
  }},
], { scales: { y: { beginAtZero: true, max: 100, grid: { color: '#21262d' } } } });

const bytesChart = defChart('bytesChart', [
  { label: 'Bytes', color: '#bc8cff', bg: 'rgba(188,140,255,0.1)', extract: d => d.bytes_written },
]);

const rangeChart = defChart('rangeChart', [
  { label: 'First Changed', color: '#d29922', extract: d => d.first_changed >= 0 ? d.first_changed : null },
  { label: 'Last Changed', color: '#f85149', extract: d => d.last_changed >= 0 ? d.last_changed : null },
  { label: 'Total Lines', color: '#58a6ff', dash: [4, 4], extract: d => d.total_lines },
]);

const heapChart = defChart('heapChart', [
  { label: 'Heap Alloc', color: '#58a6ff', bg: 'rgba(88,166,255,0.1)', extract: d => d.heap_alloc ? (d.heap_alloc / (1024 * 1024)) : null },
  { label: 'Heap In-use', color: '#bc8cff', extract: d => d.heap_inuse ? (d.heap_inuse / (1024 * 1024)) : null },
  { label: 'Heap Idle', color: '#8b949e', dash: [4, 4], extract: d => d.heap_idle ? (d.heap_idle / (1024 * 1024)) : null },
  { label: 'Stack In-use', color: '#d29922', extract: d => d.stack_inuse ? (d.stack_inuse / (1024 * 1024)) : null },
]);

const allocChart = defChart('allocChart', [
  { label: 'Mallocs (objects)', color: '#f85149', bg: 'rgba(248,81,73,0.1)', yAxisID: 'y', extract: d => d.mallocs || 0 },
  { label: 'Alloc Δ (KB)', color: '#3fb950', yAxisID: 'y1', extract: d => d.heap_alloc_delta ? (d.heap_alloc_delta / 1024) : 0 },
], {
  scales: {
    y: { beginAtZero: true, position: 'left', grid: { color: '#21262d' } },
    y1: { beginAtZero: true, position: 'right', grid: { drawOnChartArea: false } },
  }
});

const goroutineChart = defChart('goroutineChart', [
  { label: 'Goroutines', color: '#56d4dd', bg: 'rgba(86,212,221,0.1)', extract: d => d.goroutines || 0 },
]);

const gcChart = defChart('gcChart', [
  { label: 'GC Pause', color: '#d29922', bg: 'rgba(210,153,34,0.1)', extract: d => d.gc_pause_ns ? (d.gc_pause_ns / 1000) : 0 },
]);

// ── Color helpers for generation overlays ──────────────────────────────────
// Dim a hex color (#rrggbb) to a given opacity, returning rgba().
function dimColor(hex, alpha) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `rgba(${r},${g},${b},${alpha})`;
}

// ── Component stats helpers ────────────────────────────────────────────────
function frameCacheStats(frame) {
  if (!frame.components || frame.components.length === 0) return { total: 0, cached: 0 };
  let total = 0, cached = 0;
  for (const c of frame.components) {
    total++;
    if (c.cached) cached++;
  }
  return { total, cached };
}

// ── Update logic ───────────────────────────────────────────────────────────
function getWindow() {
  return parseInt(document.getElementById('windowSize').value);
}

function overlayEnabled() {
  return document.getElementById('overlayGens').checked;
}

// Stats bar always reflects the current (latest) generation.
function updateStats() {
  const allData = curGen();
  const n = allData.length;
  document.getElementById('totalFrames').textContent = n;
  if (n === 0) return;

  const totals = allData.map(d => d.total_us);
  const avg = (totals.reduce((a, b) => a + b, 0) / n) | 0;
  document.getElementById('avgTotal').textContent = avg;

  const sorted = [...totals].sort((a, b) => a - b);
  const p99 = sorted[Math.floor(n * 0.99)] || sorted[n - 1];
  document.getElementById('p99Total').textContent = p99;

  const fullRedraws = allData.filter(d => d.full_redraw);
  document.getElementById('fullRedraws').textContent = fullRedraws.length;
  if (fullRedraws.length > 0) {
    const last = fullRedraws[fullRedraws.length - 1];
    document.getElementById('lastRedrawWhy').textContent = last.full_redraw_why || '';
  }

  let totalLines = 0, totalLineCached = 0;
  for (const d of allData) {
    totalLines += d.total_lines;
    totalLineCached += d.cache_hits;
  }
  const lineRate = totalLines > 0 ? ((totalLineCached / totalLines) * 100).toFixed(1) : '-';
  document.getElementById('cacheRate').textContent = lineRate;

  let totalComps = 0, totalCompCached = 0;
  for (const d of allData) {
    const s = frameCacheStats(d);
    totalComps += s.total;
    totalCompCached += s.cached;
  }
  const compoRate = totalComps > 0 ? ((totalCompCached / totalComps) * 100).toFixed(1) : '-';
  document.getElementById('compoCacheRate').textContent = compoRate;

  const avgL = (allData.reduce((a, d) => a + d.total_lines, 0) / n).toFixed(0);
  document.getElementById('avgLines').textContent = avgL;

  const avgB = (allData.reduce((a, d) => a + d.bytes_written, 0) / n).toFixed(0);
  document.getElementById('avgBytes').textContent = avgB;

  const noop = allData.filter(d => d.first_changed === -1).length;
  document.getElementById('noopFrames').textContent = noop;

  const latest = allData[n - 1];
  if (latest.heap_alloc !== undefined) {
    document.getElementById('heapAlloc').textContent = (latest.heap_alloc / (1024 * 1024)).toFixed(1);
    document.getElementById('heapObjects').textContent = formatNum(latest.heap_objects);
    document.getElementById('goroutines').textContent = latest.goroutines;
    document.getElementById('numGC').textContent = latest.num_gc;
    document.getElementById('gcPause').textContent = ((latest.gc_pause_ns || 0) / 1000).toFixed(0);
    document.getElementById('sysMemory').textContent = (latest.sys / (1024 * 1024)).toFixed(1);
  }

  const framesWithAlloc = allData.filter(d => d.mallocs !== undefined);
  if (framesWithAlloc.length > 0) {
    const avgMallocs = (framesWithAlloc.reduce((a, d) => a + d.mallocs, 0) / framesWithAlloc.length).toFixed(0);
    const avgAllocBytes = (framesWithAlloc.reduce((a, d) => a + d.heap_alloc_delta, 0) / framesWithAlloc.length / 1024).toFixed(1);
    document.getElementById('allocsPerFrame').textContent = avgMallocs;
    document.getElementById('allocBytesPerFrame').textContent = avgAllocBytes;
  }

  // Generation indicator.
  const gi = document.getElementById('genIndicator');
  if (generations.length > 1) {
    gi.textContent = `Session ${generations.length} of ${generations.length} (${generations.map(g => g.length).join(' / ')} frames)`;
  } else {
    gi.textContent = '';
  }

  updateComponentTable();
}

function formatNum(n) {
  if (n >= 1e6) return (n / 1e6).toFixed(1) + 'M';
  if (n >= 1e3) return (n / 1e3).toFixed(1) + 'K';
  return '' + n;
}

function shortName(name) {
  const parts = name.split('.');
  return parts[parts.length - 1] || name;
}

function updateComponentTable() {
  const allData = curGen();
  const win = getWindow();
  const slice = allData.slice(-win);

  const agg = {};
  for (const frame of slice) {
    if (!frame.components) continue;
    for (const c of frame.components) {
      if (!agg[c.name]) {
        agg[c.name] = { appearances: 0, rendered: 0, cached: 0, totalUs: 0, maxUs: 0, totalLines: 0 };
      }
      const a = agg[c.name];
      a.appearances++;
      if (c.cached) {
        a.cached++;
      } else {
        a.rendered++;
        a.totalUs += c.render_us;
        if (c.render_us > a.maxUs) a.maxUs = c.render_us;
      }
      a.totalLines += c.lines;
    }
  }

  const tbody = document.getElementById('compTableBody');
  const names = Object.keys(agg).sort((a, b) => agg[b].totalUs - agg[a].totalUs);

  if (names.length === 0) {
    tbody.innerHTML = '<tr><td colspan="10" style="color:var(--dim)">No component data yet</td></tr>';
    return;
  }

  let html = '';
  for (const name of names) {
    const a = agg[name];
    const renderRate = a.appearances > 0 ? (a.rendered / a.appearances * 100) : 0;
    const avgUs = a.rendered > 0 ? (a.totalUs / a.rendered) | 0 : 0;
    const avgLines = a.appearances > 0 ? (a.totalLines / a.appearances).toFixed(1) : '0';

    let rateClass, statusText;
    if (renderRate >= 90) {
      rateClass = 'rate-high';
      statusText = '⟳ always renders';
    } else if (renderRate === 0) {
      rateClass = 'rate-low';
      statusText = '✓ fully cached';
    } else if (renderRate <= 10) {
      rateClass = 'rate-low';
      statusText = '✓ mostly cached';
    } else {
      rateClass = 'rate-mid';
      statusText = '△ partial cache';
    }

    const barColor = renderRate >= 90 ? 'var(--red)' : renderRate === 0 ? 'var(--green)' : 'var(--orange)';

    html += '<tr>'
      + '<td class="comp-name" title="' + name + '">' + shortName(name) + '</td>'
      + '<td>' + a.appearances + '</td>'
      + '<td>' + a.rendered + '</td>'
      + '<td>' + a.cached + '</td>'
      + '<td class="' + rateClass + '">' + renderRate.toFixed(0) + '%</td>'
      + '<td><span class="bar-bg"><span class="bar-fill" style="width:' + renderRate + '%;background:' + barColor + '"></span></span></td>'
      + '<td>' + avgUs + '</td>'
      + '<td>' + a.maxUs + '</td>'
      + '<td>' + avgLines + '</td>'
      + '<td class="' + rateClass + '">' + statusText + '</td>'
      + '</tr>';
  }
  tbody.innerHTML = html;
}

// ── Chart rendering with generation overlay ────────────────────────────────

// How many old generations to show behind the current one.
const MAX_OVERLAY_GENS = 5;

function updateCharts() {
  const win = getWindow();
  const overlay = overlayEnabled();
  const showFull = document.getElementById('showFullRedraws').checked;

  // Determine which generations to render.
  // Always include the current generation. When overlay is on, include
  // up to MAX_OVERLAY_GENS previous ones rendered underneath.
  const totalGens = generations.length;
  const startGen = overlay ? Math.max(0, totalGens - MAX_OVERLAY_GENS - 1) : totalGens - 1;
  const gensToRender = []; // [{data, isCurrent, genIndex}]
  for (let gi = startGen; gi < totalGens; gi++) {
    const g = generations[gi];
    if (g.length === 0) continue;
    gensToRender.push({ data: g.slice(-win), isCurrent: gi === totalGens - 1, genIndex: gi });
  }

  // Compute max frame count across all visible generations for shared X axis.
  let maxLen = 0;
  for (const g of gensToRender) {
    if (g.data.length > maxLen) maxLen = g.data.length;
  }
  const labels = Array.from({ length: maxLen }, (_, i) => i);

  for (const def of chartDefs) {
    const { chart, series } = def;
    const datasets = [];

    for (let gIdx = 0; gIdx < gensToRender.length; gIdx++) {
      const gen = gensToRender[gIdx];
      // Opacity: current = 1.0, older = progressively dimmer.
      const age = gensToRender.length - 1 - gIdx; // 0 = current
      const alpha = gen.isCurrent ? 1.0 : Math.max(0.15, 0.5 - age * 0.1);
      const bgAlpha = gen.isCurrent ? 0.1 : 0;

      for (let si = 0; si < series.length; si++) {
        const s = series[si];

        // Pad with nulls so shorter generations don't distort the chart.
        const values = gen.data.map(d => s.extract(d));

        const ds = {
          label: gen.isCurrent ? s.label : `${s.label} (S${gen.genIndex + 1})`,
          borderColor: dimColor(s.color, alpha),
          backgroundColor: gen.isCurrent && s.bg ? s.bg : (bgAlpha > 0 ? dimColor(s.color, bgAlpha) : 'transparent'),
          fill: gen.isCurrent && !!s.bg,
          data: values,
          borderWidth: gen.isCurrent ? 1.5 : 1,
          pointRadius: 0,
          pointHoverRadius: gen.isCurrent ? 3 : 0,
          borderDash: !gen.isCurrent ? [4, 2] : (s.dash || []),
          order: gen.isCurrent ? 0 : 1, // current on top
        };
        if (s.yAxisID) ds.yAxisID = s.yAxisID;
        datasets.push(ds);
      }
    }

    // Special handling: full redraw dots on the timing chart (current gen only).
    if (chart === timingChart && showFull && gensToRender.length > 0) {
      const curData = gensToRender[gensToRender.length - 1];
      if (curData && curData.isCurrent) {
        // Find the dataset for the current generation's "Total" series.
        const curDs = datasets.find(ds => ds.label === 'Total');
        if (curDs) {
          curDs.pointRadius = curData.data.map(d => d.full_redraw ? 3 : 0);
          curDs.pointBackgroundColor = curData.data.map(d => d.full_redraw ? '#f85149' : 'transparent');
        }
      }
    }

    // Special handling: GC dots on the gc chart (current gen only).
    if (chart === gcChart && gensToRender.length > 0) {
      const curData = gensToRender[gensToRender.length - 1];
      if (curData && curData.isCurrent) {
        const curDs = datasets.find(ds => ds.label === 'GC Pause');
        if (curDs) {
          curDs.pointRadius = curData.data.map((d, i) => {
            if (i === 0) return 0;
            return (d.num_gc !== curData.data[i - 1].num_gc) ? 4 : 0;
          });
          curDs.pointBackgroundColor = curData.data.map((d, i) => {
            if (i === 0) return 'transparent';
            return (d.num_gc !== curData.data[i - 1].num_gc) ? '#d29922' : 'transparent';
          });
        }
      }
    }

    // Update legend: only show entries for the current generation's series
    // to avoid legend clutter from old generations.
    chart.options.plugins.legend.labels.filter = (item) => {
      return !item.text.match(/\(S\d+\)$/);
    };

    chart.data.labels = labels;
    chart.data.datasets = datasets;
    chart.update();
  }
}

// Batch updates to avoid hammering the DOM.
let updatePending = false;
function scheduleUpdate() {
  if (updatePending) return;
  updatePending = true;
  requestAnimationFrame(() => {
    updatePending = false;
    if (!paused) {
      updateStats();
      updateCharts();
    }
  });
}

// ── SSE connection ─────────────────────────────────────────────────────────
function connect() {
  const dot = document.getElementById('statusDot');
  const sub = document.getElementById('subtitle');

  const es = new EventSource('/events');

  es.onopen = () => {
    dot.className = 'status connected';
    sub.textContent = 'Connected — streaming render stats';
  };

  es.onmessage = (e) => {
    try {
      const d = JSON.parse(e.data);
      if (d.type === 'session_start') {
        startNewGeneration();
        scheduleUpdate();
        return;
      }
      curGen().push(d);
      scheduleUpdate();
    } catch (err) {
      // skip malformed
    }
  };

  es.onerror = () => {
    dot.className = 'status disconnected';
    sub.textContent = 'Disconnected — retrying...';
    es.close();
    setTimeout(connect, 2000);
  };
}

// ── Controls ───────────────────────────────────────────────────────────────
document.getElementById('windowSize').addEventListener('change', () => {
  updateCharts();
});

document.getElementById('showFullRedraws').addEventListener('change', () => {
  updateCharts();
});

document.getElementById('overlayGens').addEventListener('change', () => {
  updateCharts();
});

document.getElementById('clearBtn').addEventListener('click', () => {
  generations.length = 0;
  generations.push([]);
  updateStats();
  updateCharts();
});

document.getElementById('pauseBtn').addEventListener('change', (e) => {
  paused = e.target.checked;
  if (!paused) {
    updateStats();
    updateCharts();
  }
});

// ── Go ─────────────────────────────────────────────────────────────────────
connect();
</script>
</body>
</html>
